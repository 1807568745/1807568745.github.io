[{"title":"序章","url":"/2021/07/17/starts/","content":"<center>\n<font size=\"6.5\">\n    「Hello World」\n\n<center><font size=\"3\">欢迎来到我的小屋。\n\n<center>平时会写一写一些学到的东西，如果喜欢的话谢谢欣赏\n\n<hr>\n<center>除了打代码，平时还喜欢看点历史，偶尔也会写个一两篇，欢迎关注我的历史小屋\n\n<p><img src=\"/2021/07/17/starts/small.jpg\"></p>\n<center>老鹰的历史小屋\n<span id=\"more\"></span></center></center></center></font></center></font></center>"},{"title":"基础算法：搜索和图论","url":"/2021/07/25/Graph/","content":"<p>一些图论的基础算法</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Data-struct-邻接表\"><a href=\"#Data-struct-邻接表\" class=\"headerlink\" title=\"Data struct : 邻接表\"></a>Data struct : 邻接表</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> h[N], e[M], ne[M], idx; <span class=\"comment\">//h[]是队头指针，e[]是节点的值，ne[]是指针，N是点数，M是边数</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">// 添加一条边a-&gt;b</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[a]; i != <span class=\"number\">-1</span>; i = ne[i]) <span class=\"comment\">//i是指针，具体的值要e[i]来读取一下</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = e[i];</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/07/25/Graph/data_struct.jpg\"></p>\n<p>新的指针 ne[ idx ] 指向原来队头的下一个节点，即c，然后队头指向新插入的节点b，完成链表头插过程</p>\n<h3 id=\"树的重心（dfs）\"><a href=\"#树的重心（dfs）\" class=\"headerlink\" title=\"树的重心（dfs）\"></a>树的重心（dfs）</h3><p><img src=\"/2021/07/25/Graph/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%831.jpg\"></p>\n<p><img src=\"/2021/07/25/Graph/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%832.jpg\"></p>\n<p>来源Acwing模板题：<a href=\"https://www.acwing.com/problem/content/description/848/\">https://www.acwing.com/problem/content/description/848/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">100010</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> e[N * <span class=\"number\">2</span>], h[N], ne[N * <span class=\"number\">2</span>], idx;  <span class=\"comment\">//因为是无向图，每个点要连两遍，所以要2*N</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n, ans = N;  <span class=\"comment\">//ans为最后结果</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> book[N];\t<span class=\"comment\">//标记某个点是否被读取过</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span>   <span class=\"comment\">//a -&gt; b</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span>   <span class=\"comment\">//返回以u为根节点的子树节点数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    book[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">1</span>, res = <span class=\"number\">0</span>;  <span class=\"comment\">//sum为返回值，根节点也算一个所以初始值为1，res为删掉u后最大连通块的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[u]; i != <span class=\"number\">-1</span>; i = ne[i])    <span class=\"comment\">//邻接表遍历</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!book[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = <span class=\"built_in\">dfs</span>(j);</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, s);</span><br><span class=\"line\">            sum += s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res = <span class=\"built_in\">max</span>(res, n - sum);  <span class=\"comment\">//除了u这棵子树以外的点组成的连通分支</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">min</span>(ans, res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b), <span class=\"built_in\">add</span>(b, a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>); <span class=\"comment\">//这里只用从1~n任意一个点开始遍历即可，也可以换成dfs(n)。比如说测试用例，从1进去后会再dfs到1的相邻节点2,4,7因此会执行dfs(2),虽然1被标记过了在执行dfs(2)的时候读取不到，但是不用读取也能计算出结果，因为在dfs的最后会把除了u这棵子树以外的点组成的连通分支和目前的res再进行一次比较，所以dfs(2)时134679这个连通分支虽然读取不到，但是也能算出来这个分支节点个数并且和ans比较</span></span><br><span class=\"line\">    cout &lt;&lt; ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"朴素Dijkstra\"><a href=\"#朴素Dijkstra\" class=\"headerlink\" title=\"朴素Dijkstra\"></a>朴素Dijkstra</h2><p>​    时间复杂度为O(n^2 + m)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> g[N][N];  <span class=\"comment\">// 存储每条边</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dist[N];  <span class=\"comment\">// 存储1号点到每个点的最短距离</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> st[N];   <span class=\"comment\">// 存储每个点的最短路是否已经确定</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i ++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = <span class=\"number\">-1</span>;     <span class=\"comment\">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++ )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!st[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[t] &gt; dist[j]))</span><br><span class=\"line\">                t = j;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 用t更新其他点的距离</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++ )</span><br><span class=\"line\">            dist[j] = <span class=\"built_in\">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class=\"line\"></span><br><span class=\"line\">        st[t] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dist[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：yxc</span><br><span class=\"line\">链接：https:<span class=\"comment\">//www.acwing.com/blog/content/405/</span></span><br><span class=\"line\">来源：AcWing</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"堆优化Dijkstra\"><a href=\"#堆优化Dijkstra\" class=\"headerlink\" title=\"堆优化Dijkstra\"></a>堆优化Dijkstra</h3><p><strong>例题</strong>：Dijkstra求最短路 II </p>\n<p><img src=\"/2021/07/25/Graph/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%891.jpg\"></p>\n<p><img src=\"/2021/07/25/Graph/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%892.jpg\"></p>\n<p>来源Acwing模板题：<a href=\"https://www.acwing.com/problem/content/852/\">https://www.acwing.com/problem/content/852/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">150010</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII; <span class=\"comment\">//first存储距离，second存节点编号</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> e[N], ne[N], d[N], h[N], w[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> book[N];\t<span class=\"comment\">//book[i] = 1表示已经找到起点到i的最短路</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">djs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(d, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> d);</span><br><span class=\"line\">    d[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  <span class=\"comment\">//greater参数生成小根堆</span></span><br><span class=\"line\">    heap.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!heap.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = heap.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        heap.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ver = t.second, dis = t.first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(book[ver]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        book[ver] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[ver]; i != <span class=\"number\">-1</span>; i = ne[i]) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis + w[i] &lt; d[j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                d[j] = dis + w[i];</span><br><span class=\"line\">                heap.<span class=\"built_in\">push</span>(&#123;d[j], j&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">//若从起点到n的最短路不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> d[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b, c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"built_in\">djs</span>();</span><br><span class=\"line\">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman_Ford\"></a>Bellman_Ford</h2><p>时间复杂度：O(nm)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n, m;       <span class=\"comment\">// n表示点数，m表示边数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dist[N];        <span class=\"comment\">// dist[x]存储1到x的最短路距离</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>     // 边，<span class=\"title\">a</span>表示出点，<span class=\"title\">b</span>表示入点，<span class=\"title\">w</span>表示边的权重</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, w;</span><br><span class=\"line\">&#125;edges[M];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bellman_ford</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++ )<span class=\"comment\">//n表示从1到n最多经过n条边</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class=\"line\">                dist[b] = dist[a] + w;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dist[n] &gt; <span class=\"number\">0x3f3f3f3f</span> / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：yxc</span><br><span class=\"line\">链接：https:<span class=\"comment\">//www.acwing.com/blog/content/405/</span></span><br><span class=\"line\">来源：AcWing</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h2><h3 id=\"求最短路\"><a href=\"#求最短路\" class=\"headerlink\" title=\"求最短路\"></a>求最短路</h3><p>​    其实就是用队列优化的bellman_ford，简单点说就是在遍历的时候，只遍历d[]值变小的点，因为d[]值不变的点必定不会对结果有影响。</p>\n<p>​    只要图里没有负权环就可以用，一般O(n)，最坏O(nm)，其实一般负权图都不会有负环。spfa其实对于很多正权图也是很适用的，（只要不被出题人卡</p>\n<p>​    <strong>例题</strong>：SPFA求最短路   来源ACwing模板题：<a href=\"https://www.acwing.com/problem/content/description/853/\">https://www.acwing.com/problem/content/description/853/</a></p>\n<p><img src=\"/2021/07/25/Graph/SPFA1.jpg\"></p>\n<p><img src=\"/2021/07/25/Graph/SPFA2.jpg\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">100010</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> e[N], ne[N], h[N], w[N], d[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> book[N];    <span class=\"comment\">//book[i] = 1 表示i已经在队列里，等于0表示不在队列里</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(d, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> d);</span><br><span class=\"line\">    d[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;       <span class=\"comment\">//初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\">    queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    book[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        book[t] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[t]; i != <span class=\"number\">-1</span>; i = ne[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[t] + w[i] &lt; d[j])  <span class=\"comment\">//若经过t到j的距离比直接到j的距离要短</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                d[j] = d[t] + w[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!book[j])  <span class=\"comment\">//若j不在队列里</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(j);</span><br><span class=\"line\">                    book[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> d[n]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b, c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"built_in\">spfa</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t == <span class=\"number\">-1</span>) cout &lt;&lt; <span class=\"string\">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"找负权环\"><a href=\"#找负权环\" class=\"headerlink\" title=\"找负权环\"></a>找负权环</h3><p>​    判断一个图中是否有负权回路一般都用SPFA，做法是在代码中加入一个cnt[]数组，cnt[i] 存放1到 i 的最短路上经过的边数。若cnt[i] &gt;= n，则这条路上一定有n+1或以上个点，就必定有两个或以上重复点，又由于是最短路上的，所以必定存在负权环。</p>\n<p>​    代码实现，在上方代码spfa函数while里的for循环里的if下面插入:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnt[j] = cnt[t] + <span class=\"number\">1</span>;   </span><br><span class=\"line\"><span class=\"keyword\">if</span>(cnt[j] &gt;= n) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>​    同时初始时要把所有的点都放进队列：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        book[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    如果还是只放起点的话，若是图中的负权环是起点到不了的，就找不到了。因此干脆就把所有的点都放进去，这样不管负权环在哪，只要存在就一定能找得到。</p>\n<h2 id=\"Floyd\"><a href=\"#Floyd\" class=\"headerlink\" title=\"Floyd\"></a>Floyd</h2><p>​    Floyd的原理是动态规划：d[k,i,j]表示从i到j只经过1~k号点的最短路的距离，d[k,i,j] = min(d[k,i,j], d[k-1,i,k] + d[k-1,k,j])。然后第一维可以略去，就是下面的形式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k ++)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++)</span><br><span class=\"line\">\t\t\td[i][j] = <span class=\"built_in\">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br></pre></td></tr></table></figure>\n\n<p>​    最后所得d中d[ i ] [ j ]就表示i~j最短距离</p>\n<h2 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h2><h3 id=\"Prim\"><a href=\"#Prim\" class=\"headerlink\" title=\"Prim\"></a>Prim</h3><p>​    朴素Prim时间复杂度为O(n^2)，堆优化为O(m logn)</p>\n<p>​    从图中任意一点u开始，记集合U = {u}，每次找到一个离集合最近的、不在集合当中的点，并入集合，直到所有点都被并入集合。</p>\n<p><img src=\"/2021/07/25/Graph/Prim.jpg\"></p>\n<center>\n    <font size=\"2\">\n    图片来源：清华大学教程《数据结构》(严蔚敏、吴伟民编著) 插图\n</font></center>\n\n<h3 id=\"Kruskal\"><a href=\"#Kruskal\" class=\"headerlink\" title=\"Kruskal\"></a>Kruskal</h3><p>​    时间复杂度为O(m logm)</p>\n<p>​    先将所有边按从小到大的顺序排序，之后每次选择边权最小且边的两点不在同一连通块的边，加入集合，直到所有点都在集合内。最后所得集合就是最小生成树。</p>\n<p><img src=\"/2021/07/25/Graph/Kruskal.jpg\"></p>\n<center>\n    <font size=\"2\">\n    图片来源：清华大学教程《数据结构》(严蔚敏、吴伟民编著) 插图\n</font></center>\n\n\n<h2 id=\"染色法判断二分图\"><a href=\"#染色法判断二分图\" class=\"headerlink\" title=\"染色法判断二分图\"></a>染色法判断二分图</h2><p>​    定理：一个图是二分图的<strong>充要</strong>条件是，该图没有<strong>奇数环</strong>。</p>\n<p>​    因此可以用染色法来判断二分图。具体做法是从一个没有颜色的点开始染色，例如用黑白两色来染。某一起始点 x 染上黑色后，所有的邻点都染上白色，x的邻点的邻点又染黑色，直到所有的点都有颜色，如果没有出现冲突的情况，就说明这个图是二分图。该算法的时间复杂度为O(n + m)</p>\n<p>​    <strong>例题</strong>：染色法判断二分图    来源Acwing模板题：<a href=\"https://www.acwing.com/problem/content/862/\">https://www.acwing.com/problem/content/862/</a></p>\n<p><img src=\"/2021/07/25/Graph/%E6%9F%93%E8%89%B2%E6%B3%95.jpg\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">100010</span>, M = <span class=\"number\">200010</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> h[N], e[M], ne[M];\t</span><br><span class=\"line\"><span class=\"keyword\">int</span> color[N];  <span class=\"comment\">//存放节点的颜色，1是一种颜色，2是另一种颜色</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    color[u] = c;   <span class=\"comment\">//染色</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[u]; i != <span class=\"number\">-1</span>; i = ne[i])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!color[j])   <span class=\"comment\">//若当前点没有颜色</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">dfs</span>(j, <span class=\"number\">3</span> - c)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">//dfs(j, 3-c)=false表示对j染色出现矛盾</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(color[j] == c) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b), <span class=\"built_in\">add</span>(b, a);   <span class=\"comment\">//无向图，存两条边</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++) <span class=\"comment\">//遍历所有点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!color[i])  <span class=\"comment\">//若该点没有颜色</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">dfs</span>(i, <span class=\"number\">1</span>))\t<span class=\"comment\">//若对i点染色的过程出现了矛盾</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;\t<span class=\"comment\">//说明该图不是二分图</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"匈牙利算法\"><a href=\"#匈牙利算法\" class=\"headerlink\" title=\"匈牙利算法\"></a>匈牙利算法</h2><p>​    匈牙利算法的作用是返回一个二分图的最大匹配。举个例子，令一个二分图分成a和b两个部分。从a部分开始遍历（从b部分开始也可以），如a[ i ]找和其相连的b部分的对应点b[ j ]形成配对。如果出现冲突，也就是b[ j ]已近和其他的点a[ x ]配对了，那就反过来看看a[ x ]能不能和别的配对，找个下家，如果可以的话b[ j ]就可以空出来和a[ i ]配对了。</p>\n<p>​    时间复杂度为O(mn)，实际运行时间一般远小于O(mn)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 &#123;E&#125; 中的任意两条边都不依附于同一个顶点（没有任何一个点在多条边上，也就是说一个点只和一条边配对），则称 M 是一个匹配。</span><br><span class=\"line\">二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</span><br></pre></td></tr></table></figure>\n\n<p>例题：二分图的最大匹配    来源Acwing模板题：<a href=\"https://www.acwing.com/problem/content/863/\">https://www.acwing.com/problem/content/863/</a></p>\n<p><img src=\"/2021/07/25/Graph/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%951.jpg\"></p>\n<p><img src=\"/2021/07/25/Graph/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%952.jpg\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">510</span>, M = <span class=\"number\">100010</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> h[N], e[M], ne[M];</span><br><span class=\"line\"><span class=\"keyword\">int</span> match[N];   <span class=\"comment\">//match[i]是和b[i]配对的a部分中的某个点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> book[N];    <span class=\"comment\">//book[]的作用是在想办法腾出位置（回溯）的时候，防止回溯过程中又读取到这个点。比如说现在a[i]想和b[i]配对，但是b[i]在之前已经和a[j]配对了，于是看看能不能让a[j]和另一个配对把b[i]的位置腾出来，这里就需要find(a[j])。为了防止find(a[j])的时候a[j]又读取到b[i]，就要来一个book，先帮a[i]“占位置”</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n1, n2, m, idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span>     <span class=\"comment\">//在b部分中找和x配对的点，找得到返回true</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[x]; i != <span class=\"number\">-1</span>; i = ne[i])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!book[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            book[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(match[j] == <span class=\"number\">0</span> || <span class=\"built_in\">find</span>(match[j]))  <span class=\"comment\">//若当前j点没有和a部分的点匹配或者能把j的位置腾出来</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                match[j] = x;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b);  <span class=\"comment\">//只用连一条边就好了，因为整个算法过程都只遍历从a到b的边，不会用到b到a</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n1; i ++)  <span class=\"comment\">//任选两个部分其中一个开始遍历</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> book);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(i))</span><br><span class=\"line\">            res ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["Algorithm"],"tags":["Graph"]},{"title":"Ros","url":"/2021/07/20/Ros1/","content":"<h2 id=\"Ros学习笔记（一）\"><a href=\"#Ros学习笔记（一）\" class=\"headerlink\" title=\"Ros学习笔记（一）\"></a>Ros学习笔记（一）</h2><p>一些Linux基础命令</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Linux基础命令\"><a href=\"#Linux基础命令\" class=\"headerlink\" title=\"Linux基础命令\"></a>Linux基础命令</h3><h5 id=\"快捷键：Ctrl-Alt-t-打开终端\"><a href=\"#快捷键：Ctrl-Alt-t-打开终端\" class=\"headerlink\" title=\"快捷键：Ctrl+Alt+t 打开终端\"></a>快捷键：Ctrl+Alt+t 打开终端</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pwd  \t\t//显示当前终端工作目录的绝对路径</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd /home/   //进入home</span><br><span class=\"line\">$ cd ..      //返回上一级目录</span><br></pre></td></tr></table></figure>\n\n<p>​    <img src=\"/2021/07/20/Ros1/cd.jpg\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir (文件夹名)    //make direction:创建一个新的文件夹</span><br><span class=\"line\">$ ls               //list:查看当前路径下有哪些文件</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ touch test\t\t//在当前路径新建一个名为test的文件</span><br><span class=\"line\">$ mv test /home/laoyin/\t\t//move:把test剪切到目标位置/home/laoyin/下</span><br><span class=\"line\">$ cp test /home/laoyin/(new_name)\t//copy:把test复制到目标位置下，同时给新的test改个名字，也可以什么都不加</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rm test\t//remove:删除当前路径下的test文件</span><br><span class=\"line\">$ rm -r test\t//删除当前路径下的test文件夹</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo \t\t//提升当前用户的权限</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-amp-Python\"><a href=\"#C-amp-Python\" class=\"headerlink\" title=\"C++ &amp; Python\"></a>C++ &amp; Python</h3><p>首先先安装c++和python的编译器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install g++\t\t//cpp</span><br><span class=\"line\">$ sudo apt-get install python\t//python</span><br></pre></td></tr></table></figure>\n\n<p>c++的代码执行之前要先在终端里面编译，然后才能用终端执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ xxx.cpp -o xxx</span><br></pre></td></tr></table></figure>\n\n<p>这时候就会生成一个名为“xxx”的可执行文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./xxx</span><br></pre></td></tr></table></figure>\n\n<p>然后就用“./”（运行某个程序或者脚本），就可以运行了</p>\n<p>python不用编译，直接执行就行了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python xxx.py</span><br></pre></td></tr></table></figure>\n\n","categories":["Ros"],"tags":["Ros"]}]