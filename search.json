[{"title":"STL","url":"/2021/09/08/STL/","content":"\n关于一些cpp STL库函数的用法\n\n万能头文件 ： #include<bits/stdc++.h>\n\n<!-- more -->\n\n### unordered_map\n\n------\n\n哈希表，也可以当字典来用\n\n比如：\n\n```c++\nunordered_map<string, int> ss;\nss[\"laoyin\"] = 666;\n```\n\n这时候 cout << ss[\"laoyin\"] 就会输出666\n\n也可以：\n\n```cpp\nss.insert({\"laoyin\", 666});\n```\n\n如果想要哈希表里面的值（即ss[\"laoyin\"]）迭代增加或者减小的话，可以直接：\n\n```c++\nss[\"laoyin\"] ++;\n```\n\n遍历ss里面的值的话，可以\n\n```c++\nint res = 0;\nfor(auto& [k, v] : ss) res = max(res, v);\n```\n\n### unordered_set\n\n------\n\n和set一样，一个不允许有重复元素的容器\n\n```c++\nunordered_set<int> ss;\nss.insert(1);\ncout << ss.count(1) << endl;  //输出1\n```\n\n可以用 ss.count(a) 来判断set中是否存在a，由于set中不允许出现重复元素，因此返回值只有0 和 1。\n","tags":["STL"]},{"title":"基础算法：搜索和图论","url":"/2021/07/25/Graph/","content":"\n一些图论的基础算法\n\n<!-- more -->\n\n## Data struct : 邻接表\n\n```cpp\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[M], ne[M], idx; //h[]是队头指针，e[]是节点的值，ne[]是指针，N是点数，M是边数\n\t\n// 添加一条边a->b\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);\n\n//遍历：\nfor(int i = h[a]; i != -1; i = ne[i]) //i是指针，具体的值要e[i]来读取一下\n\tint b = e[i];\n\t...\n```\n\n![](Graph/data_struct.jpg)\n\n新的指针 ne[ idx ] 指向原来队头的下一个节点，即c，然后队头指向新插入的节点b，完成链表头插过程\n\n### 树的重心（dfs）\n\n![](Graph/树的重心1.jpg)\n\n![](Graph/树的重心2.jpg)\n\n来源Acwing模板题：https://www.acwing.com/problem/content/description/848/\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <queue>\nusing namespace std;\nconst int N = 100010;\nint e[N * 2], h[N], ne[N * 2], idx;  //因为是无向图，每个点要连两遍，所以要2*N\nint n, ans = N;  //ans为最后结果\nint book[N];\t//标记某个点是否被读取过\nvoid add(int a, int b)   //a -> b\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;\n}\nint dfs(int u)   //返回以u为根节点的子树节点数\n{\n    book[u] = 1;\n    \n    int sum = 1, res = 0;  //sum为返回值，根节点也算一个所以初始值为1，res为删掉u后最大连通块的节点数量\n    for(int i = h[u]; i != -1; i = ne[i])    //邻接表遍历\n    {\n        int j = e[i];\n        if(!book[j])\n        {\n            int s = dfs(j);\n            res = max(res, s);\n            sum += s;\n        }\n    }\n    res = max(res, n - sum);  //除了u这棵子树以外的点组成的连通分支\n    ans = min(ans, res);\n    return sum;\n\n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n;\n    for(int i = 1; i <= n - 1; i ++)\n    {\n        int a, b;\n        cin >> a >> b;\n        add(a, b), add(b, a);\n    }\n    dfs(1); //这里只用从1~n任意一个点开始遍历即可，也可以换成dfs(n)。比如说测试用例，从1进去后会再dfs到1的相邻节点2,4,7因此会执行dfs(2),虽然1被标记过了在执行dfs(2)的时候读取不到，但是不用读取也能计算出结果，因为在dfs的最后会把除了u这棵子树以外的点组成的连通分支和目前的res再进行一次比较，所以dfs(2)时134679这个连通分支虽然读取不到，但是也能算出来这个分支节点个数并且和ans比较\n    cout << ans;\n    return 0;\n}\n```\n\n## 朴素Dijkstra\n\n​\t时间复杂度为O(n^2 + m)\n\n```cpp\nint g[N][N];  // 存储每条边\nint dist[N];  // 存储1号点到每个点的最短距离\nbool st[N];   // 存储每个点的最短路是否已经确定\n\n// 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    for (int i = 0; i < n - 1; i ++ )\n    {\n        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j <= n; j ++ )\n            if (!st[j] && (t == -1 || dist[t] > dist[j]))\n                t = j;\n\n        // 用t更新其他点的距离\n        for (int j = 1; j <= n; j ++ )\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n\n        st[t] = true;\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\n作者：yxc\n链接：https://www.acwing.com/blog/content/405/\n来源：AcWing\n```\n\n### 堆优化Dijkstra\n\n**例题**：Dijkstra求最短路 II \n\n![](Graph/迪杰斯特拉1.jpg)\n\n![](Graph/迪杰斯特拉2.jpg)\n\n来源Acwing模板题：https://www.acwing.com/problem/content/852/\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 150010;\ntypedef pair<int, int> PII; //first存储距离，second存节点编号\nint e[N], ne[N], d[N], h[N], w[N];\nint book[N];\t//book[i] = 1表示已经找到起点到i的最短路\nint n, m, idx;\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n}\nint djs()\n{\n    memset(d, 0x3f, sizeof d);\n    d[1] = 0;\n    \n    priority_queue<PII, vector<PII>, greater<PII>> heap;  //greater参数生成小根堆\n    heap.push({0, 1});\n    while(!heap.empty())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, dis = t.first;\n        if(book[ver]) continue;\n        book[ver] = 1;\n\n        for(int i = h[ver]; i != -1; i = ne[i]) \n        {\n            int j = e[i];\n            if(dis + w[i] < d[j])\n            {\n                d[j] = dis + w[i];\n                heap.push({d[j], j});\n            }\n        } \n        \n    }\n    if(d[n] == 0x3f3f3f3f) return -1; //若从起点到n的最短路不存在\n    else return d[n];\n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        add(a, b, c);\n    }\n   \n    int t = djs();\n    cout << t << endl;\n    return 0;\n}\n```\n\n## Bellman_Ford\n\n时间复杂度：O(nm)\n\n```cpp\nint n, m;       // n表示点数，m表示边数\nint dist[N];        // dist[x]存储1到x的最短路距离\n\nstruct Edge     // 边，a表示出点，b表示入点，w表示边的权重\n{\n    int a, b, w;\n}edges[M];\n\n// 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i = 0; i < n; i ++ )//n表示从1到n最多经过n条边\n    {\n        for (int j = 0; j < m; j ++ )\n        {\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            if (dist[b] > dist[a] + w)\n                dist[b] = dist[a] + w;\n        }\n    }\n\n    if (dist[n] > 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n}\n\n作者：yxc\n链接：https://www.acwing.com/blog/content/405/\n来源：AcWing\n```\n\n## SPFA\n\n### 求最短路\n\n​\t其实就是用队列优化的bellman_ford，简单点说就是在遍历的时候，只遍历d[]值变小的点，因为d[]值不变的点必定不会对结果有影响。\n\n​\t只要图里没有负权环就可以用，一般O(n)，最坏O(nm)，其实一般负权图都不会有负环。spfa其实对于很多正权图也是很适用的，（只要不被出题人卡\n\n​\t**例题**：SPFA求最短路   来源ACwing模板题：https://www.acwing.com/problem/content/description/853/\n\n![](Graph/SPFA1.jpg)\n\n![](Graph/SPFA2.jpg)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint e[N], ne[N], h[N], w[N], d[N];\nint book[N];    //book[i] = 1 表示i已经在队列里，等于0表示不在队列里\nint n, m, idx;\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n}\nint spfa()\n{\n    memset(d, 0x3f, sizeof d);\n    d[1] = 0;       //初始化\n\n    queue<int> q;\n    q.push(1);\n    book[1] = 1;\n    while(!q.empty())\n    {\n        auto t = q.front();\n        q.pop();\n        book[t] = 0;\n        \n        for(int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if(d[t] + w[i] < d[j])  //若经过t到j的距离比直接到j的距离要短\n            {\n                d[j] = d[t] + w[i];\n                if(!book[j])  //若j不在队列里\n                {\n                    q.push(j);\n                    book[j] = 1;\n                }\n            }\n        }\n    }\n    if(d[n] == 0x3f3f3f3f) return -1;\n    else return d[n]; \n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        add(a, b, c);\n    }\n    int t = spfa();\n    if(t == -1) cout << \"impossible\" << endl;\n    else cout << t << endl;\n    return 0;\n}\n```\n\n### 找负权环\n\n​\t判断一个图中是否有负权回路一般都用SPFA，做法是在代码中加入一个cnt[]数组，cnt[i] 存放1到 i 的最短路上经过的边数。若cnt[i] >= n，则这条路上一定有n+1或以上个点，就必定有两个或以上重复点，又由于是最短路上的，所以必定存在负权环。\n\n​\t代码实现，在上方代码spfa函数while里的for循环里的if下面插入:\n\n```cpp\n\tcnt[j] = cnt[t] + 1;   \n\tif(cnt[j] >= n) return true;\n```\n\n​\t同时初始时要把所有的点都放进队列：\n\n```cpp\nfor(int i = 1; i <= n; i ++)\n    {\n        q.push(i);\n        book[i] = 1;\n    }\n```\n\n​\t如果还是只放起点的话，若是图中的负权环是起点到不了的，就找不到了。因此干脆就把所有的点都放进去，这样不管负权环在哪，只要存在就一定能找得到。\n\n## Floyd\n\n​\tFloyd的原理是动态规划：d[k,i,j]表示从i到j只经过1~k号点的最短路的距离，d[k,i,j] = min(d[k,i,j], d[k-1,i,k] + d[k-1,k,j])。然后第一维可以略去，就是下面的形式\n\n```cpp\nfor(int k = 1; k <= n; k ++)\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n```\n\n​\t最后所得d中d[ i ] [ j ]就表示i~j最短距离\n\n## 最小生成树\n\n### Prim\n\n​\t朴素Prim时间复杂度为O(n^2)，堆优化为O(m logn)\n\n​\t从图中任意一点u开始，记集合U = {u}，每次找到一个离集合最近的、不在集合当中的点，并入集合，直到所有点都被并入集合。\n\n![](Graph/Prim.jpg)\n\n<center>\n    <font size = 2>\n    图片来源：清华大学教程《数据结构》(严蔚敏、吴伟民编著) 插图\n</center>\n\n### Kruskal\n\n​\t时间复杂度为O(m logm)\n\n​\t先将所有边按从小到大的顺序排序，之后每次选择边权最小且边的两点不在同一连通块的边，加入集合，直到所有点都在集合内。最后所得集合就是最小生成树。\n\n![](Graph/Kruskal.jpg)\n\n<center>\n    <font size = 2>\n    图片来源：清华大学教程《数据结构》(严蔚敏、吴伟民编著) 插图\n</center>\n\n\n## 染色法判断二分图\n\n​\t定理：一个图是二分图的**充要**条件是，该图没有**奇数环**。\n\n​\t因此可以用染色法来判断二分图。具体做法是从一个没有颜色的点开始染色，例如用黑白两色来染。某一起始点 x 染上黑色后，所有的邻点都染上白色，x的邻点的邻点又染黑色，直到所有的点都有颜色，如果没有出现冲突的情况，就说明这个图是二分图。该算法的时间复杂度为O(n + m)\n\n​\t**例题**：染色法判断二分图\t来源Acwing模板题：https://www.acwing.com/problem/content/862/\n\n![](Graph/染色法.jpg)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100010, M = 200010;\nint h[N], e[M], ne[M];\t\nint color[N];  //存放节点的颜色，1是一种颜色，2是另一种颜色\nint n, m, idx;\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;\n}\nbool dfs(int u, int c)\n{\n    color[u] = c;   //染色\n    for(int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if(!color[j])   //若当前点没有颜色\n        {\n            if(!dfs(j, 3 - c)) return false;  //dfs(j, 3-c)=false表示对j染色出现矛盾\n        }\n        else if(color[j] == c) return false;\n    }\n    return true;\n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int a, b;\n        cin >> a >> b;\n        add(a, b), add(b, a);   //无向图，存两条边\n    }\n    int flag = 1;\n    for(int i = 1; i <= n; i ++) //遍历所有点\n    {\n        if(!color[i])  //若该点没有颜色\n        {\n            if(!dfs(i, 1))\t//若对i点染色的过程出现了矛盾\n            {\n                flag = 0;\t//说明该图不是二分图\n                break;\n            }\n        }\n        \n    }\n    if(flag) puts(\"Yes\");\n    else puts(\"No\");\n}\n```\n\n## 匈牙利算法\n\n​\t匈牙利算法的作用是返回一个二分图的最大匹配。举个例子，令一个二分图分成a和b两个部分。从a部分开始遍历（从b部分开始也可以），如a[ i ]找和其相连的b部分的对应点b[ j ]形成配对。如果出现冲突，也就是b[ j ]已近和其他的点a[ x ]配对了，那就反过来看看a[ x ]能不能和别的配对，找个下家，如果可以的话b[ j ]就可以空出来和a[ i ]配对了。\n\n​\t时间复杂度为O(mn)，实际运行时间一般远小于O(mn)。\n\n```\n\t二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点（没有任何一个点在多条边上，也就是说一个点只和一条边配对），则称 M 是一个匹配。\n\t二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。\n```\n\n例题：二分图的最大匹配\t来源Acwing模板题：https://www.acwing.com/problem/content/863/\n\n![](Graph/匈牙利算法1.jpg)\n\n![](Graph/匈牙利算法2.jpg)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 510, M = 100010;\nint h[N], e[M], ne[M];\nint match[N];   //match[i]是和b[i]配对的a部分中的某个点\nint book[N];    //book[]的作用是在想办法腾出位置（回溯）的时候，防止回溯过程中又读取到这个点。比如说现在a[i]想和b[i]配对，但是b[i]在之前已经和a[j]配对了，于是看看能不能让a[j]和另一个配对把b[i]的位置腾出来，这里就需要find(a[j])。为了防止find(a[j])的时候a[j]又读取到b[i]，就要来一个book，先帮a[i]“占位置”\nint n1, n2, m, idx;\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;\n}\nbool find(int x)     //在b部分中找和x配对的点，找得到返回true\n{\n    for(int i = h[x]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if(!book[j])\n        {\n            book[j] = 1;\n            if(match[j] == 0 || find(match[j]))  //若当前j点没有和a部分的点匹配或者能把j的位置腾出来\n            {\n                match[j] = x;\n                return true;\n            }\n        }  \n    }\n    return false;\n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n1 >> n2 >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int a, b;\n        cin >> a >> b;\n        add(a, b);  //只用连一条边就好了，因为整个算法过程都只遍历从a到b的边，不会用到b到a\n    }\n    int res = 0;\n    for(int i = 1; i <= n1; i ++)  //任选两个部分其中一个开始遍历\n    {\n        memset(book, 0, sizeof book);\n        if(find(i))\n            res ++;\n    }\n    cout << res << endl;\n    return 0;\n}\n```\n\n\n\n","tags":["Graph"],"categories":["Algorithm"]},{"title":"Ros","url":"/2021/07/20/Ros1/","content":"\n## Ros学习笔记（一）\n\n一些Linux基础命令\n\n<!-- more -->\n\n### Linux基础命令\n\n##### 快捷键：Ctrl+Alt+t 打开终端\n\n```\n$ pwd  \t\t//显示当前终端工作目录的绝对路径\n```\n\n```\n$ cd /home/   //进入home\n$ cd ..      //返回上一级目录\n```\n\n​\t![](Ros1/cd.jpg)\n\n```\n$ mkdir (文件夹名)    //make direction:创建一个新的文件夹\n$ ls               //list:查看当前路径下有哪些文件\n```\n\n```\n$ touch test\t\t//在当前路径新建一个名为test的文件\n$ mv test /home/laoyin/\t\t//move:把test剪切到目标位置/home/laoyin/下\n$ cp test /home/laoyin/(new_name)\t//copy:把test复制到目标位置下，同时给新的test改个名字，也可以什么都不加\n```\n\n```\n$ rm test\t//remove:删除当前路径下的test文件\n$ rm -r test\t//删除当前路径下的test文件夹\n```\n\n```\n$ sudo \t\t//提升当前用户的权限\n```\n\n### C++ & Python\n\n首先先安装c++和python的编译器\n\n```\n$ sudo apt-get install g++\t\t//cpp\n$ sudo apt-get install python\t//python\n```\n\nc++的代码执行之前要先在终端里面编译，然后才能用终端执行\n\n```\n$ g++ xxx.cpp -o xxx\n```\n\n这时候就会生成一个名为“xxx”的可执行文件\n\n```\n$ ./xxx\n```\n\n然后就用“./”（运行某个程序或者脚本），就可以运行了\n\npython不用编译，直接执行就行了\n\n```\n$ python xxx.py\n```\n\n","tags":["Ros"],"categories":["Ros"]},{"title":"序章","url":"/2021/07/17/starts/","content":"\n<center>\n<font size = 6.5>\n    「Hello World」\n\n<center><font size = 3>欢迎来到我的小屋。\n\n<center>平时会写一写一些学到的东西，如果喜欢的话谢谢欣赏\n\n------\n\n<center>除了打代码，平时还喜欢看点历史，偶尔也会写个一两篇，欢迎关注我的历史小屋\n\n![](starts/small.jpg)\n\n<center>老鹰的历史小屋\n<!-- more -->"}]