[{"title":"Python工具库","url":"/2022/02/12/pdf-python/","content":"\n​\t一些比较好用的python工具，xlrd用于处理xls和xlsx（excel），pdfplumber用于处理pdf\n\n<!-- more -->\n\n## xlrd And xlwt\n\n​\t\txlrd用于读取xls，xlwt用于写xls\n\n​\t\t使用前需import：\n\n```python\nimport xlrd\nimport xlwt\n```\n\n### xlrd\n\n​\t\txlrd打开文件：\n\n```python\nexcel = xlrd.open_workbook(\"C://路径//文件名.xlsx\")\ngraph = excel.sheets()[i]\t\t#i表示文件里的第i个表\n```\n\n```python\ngraph.nrows\t\t#总行数，可以当成一个变量直接用\ngraph.ncols\t\t#总列数\n```\n\n​\t\t读取表中内容：\n\n```python\nvalue = graph.col_values(1)[i]\t\t#读取第1列（从0开始），第i行的数据\n#或\nvalue = graph.row_values(1)[i]\t\t#读取第1行（从0开始），第i列的数据\n```\n\n### xlwt\t\n\n​\t\t创建一个xlsx文件：\n\n```python\nxl = xlwt.Workbook(encoding=\"utf-8\")\nsheet = xl.add_sheet(\"name\", cell_overwrite_ok=True)\t\t#在文件中创一个名为\"name\"的表，第二个参数指是否允许单元格重复写入\n```\n\n​\t\t写入：\n\n```python\nsheet.write(i, j, \"字符串\")\t\t#在表的第i行，第j列写入字符串\n```\n\n​\t\tpython运行过程中创的表是不会自动保存的，因此需要人工保存到自己的电脑上：\n\n```python\nxl.save(\"C://路径//name.xls\")    \n```\n\n## pdfplumber\n\n​\t\t使用前需要import\n\n```python\nimport pdfplumber\n```\n\n​\t\t打开pdf文档：\n\n```python\nwith pdfplumber.open(path) as pdf:\n    pass\t\t\t#之后操作都要在with下面进行\n```\n\n​\t\t读取pdf文档全篇内容：\n\n```python\ncontent = \"\"\nwith pdfplumber.open(path) as pdf:\n    for num in range(len(pdf.pages)):    #遍历pdf所有页\n    \tst = pdf.pages[num].extract_text()     #读取第num页的内容\n        content += st\n```\n\n","tags":["tools_python"],"categories":["Python"]},{"title":"Selenium 基本操作","url":"/2022/01/25/selenium/","content":"\n 一些Selenium的基本操作\n\n<!-- more -->\n\n​\t\t在开始操作之前，先要进行一系列初始化操作：\n\n```python\nweb = webdriver.Chrome()     #创建一个webdriver对象，指明用Chrome驱动\nurl = \"http://www.cninfo.com.cn/new/index\"\nweb.get(url)\t\t#打开指定网址\nweb.maximize_window()\t\t#窗口最大化\n```\n\n## 选择元素\n\n​\t一般使用find_element方法选择元素。如果有多个满足条件的元素，那么find_element会返回第一个元素，如果想选择所有满足条件的元素，可以用 **find_elements** 。该方法会返回一个**列表**，里面包括所有满足条件的元素。\n\n```python\nelement = web.find_element(By.CLASS_NAME, 'calss的名字')\n```\n\n​\t如果需要借助By来传入定位方法的话，需要引入：\n\n```python\nfrom selenium.webdriver.common.by import By\n```\n\n​\t下面是八种定位方式和By中属性对应清单：\n\n|     定位方式      |          By          |\n| :---------------: | :------------------: |\n|        id         |        By.ID         |\n|       name        |       By.NAME        |\n|    class_name     |    By.CLASS_NAME     |\n|     tag_name      |     By.TAG_NAME      |\n|     link_text     |     By.LINK_TEXT     |\n| partial_link_text | By.PARTIAL_LINK_TEXT |\n|   css_selector    |   By.CSS_SELECTOR    |\n|       xpath       |       By.XPATH       |\n\n```\n\tf12打开 开发者工具后可以直接复制元素的xpath路径，比较方便\n```\n\n​\t不想用By的话，也可以直接上类似这种写法：find_element_by_id()。不过在Selenium升到版本4之后，这种方法已经是不赞成的过期写法了。\n\n------\n\n​\t需要注意的一点是，一个元素可能会有**多个class类型**，多个class之间用空格隔开，例如：\n\n```html\n<span class=\"Test1 Test2\">test</span>\n```\n\n​\t\t这个元素有两个class：Test1 和 Test2，要选择的话，下面两句都能正确选中：\n\n```python\nelement = web.find_element(By.CLASS_NAME,'Test1')\n\t\t\t或\nelement = web.find_element(By.CLASS_NAME,'Test2')\n```\n\n​\t\t但是这样是错误的：\n\n```python\nelement = wd.find_element(By.CLASS_NAME,'Test1 Test2')\t\t#错误，不能这样写\n```\n\n------\n\n​\t\t有时候一些元素可能还没加载出来，但是如果代码执行比网页加载速度快的话，就会出现找不到元素的情况，为了防止这种情况，可以使用**implicitly_wait**方法：\n\n```python\nweb.implicitly_wait(10)\n```\n\n​\t\t加上这句之后，后续的find_element和find_elements之类的方法都会采取如下策略：\n\n​\t\t若找不到元素，每隔半秒再找一次，直到找到元素，或者超过了10秒的最大时长\n\n## 操控元素\n\n​\t\t点击元素：\n\n```python\nelement.click()\n```\n\n### 输入框：\n\n​\t\t清空输入框里的内容：\n\n```python\nelement.clear()\n```\n\n​\t\t输入字符串：\n\n```python\nelement.send_keys('字符串')\n```\n\n------\n\n​\t\t读取元素文本内容：\n\n```python\nprint(element.text)\n```\n\n​\t\t获取元素属性，可以用**get_attribute**方法。比如要获取元素class的值，可以：\n\n```python\nelement.get_attribute('class')\n```\n\n### 窗口：\n\n​\t\t当前浏览器的所有窗口都在一个列表：**web.window_handles**里，因此若是想切换到最新窗口，即：\n\n```python\nweb.switch_to.window(web.window_handles[-1])\n```\n\n​\t\t保存当前窗口，以便等会切换回来：\n\n```python\norigin_handle = web.current_window_handle\t\t#保存当前窗口\nweb.switch_to.window(origin_handle)\t\t\t\t#切换回原窗口\n```\n\n​\t\t关闭当前窗口：\n\n```python\nweb.close()  \n```\n\n​\t\t刷新：\n\n```python\nweb.refresh()\n```\n\n### 读取元素信息\n\n​\t\t比如说，再通过如下代码得到对应的元素列表之后：\n\n```python\ntargets = web.find_elements(By.CSS_SELECTOR, \"div[class = 'cell'] > a\")\n```\n\n​\t\t我们想要的是如下这个data-seccode为000002的 a\n\n![](selenium/attribute.jpg)\n\n​\t\t可以通过**get_attribute**方法，在列表中锁定我们想要的元素：\n\n```python\nfor target in targets:\n        if target.get_attribute(\"data-seccode\") == \"000002\":   #\"000002\"是字符串\n        \tpass\n```\n\n​\t\t**get_attribute**方法括号里面的参数就是属性名，同理也可以：\n\n```python\ntarget.get_attribute(\"class\")\ntarget.get_attribute(\"href\")\n```\n\n","tags":["Selenium"],"categories":["Web Automation"]},{"title":"零碎的算法知识点","url":"/2021/12/06/tip/","content":"\n 记录一下刷题过程中遇到的一些小知识点\n\n<!-- more -->\n\n### 链表\n\n定义一个链表：\n\n```cpp\nstruct ListNode\n{\n    int value;\n    ListNode *next;\n};\n```\n\n创建一个新节点（自动分配空间）：\n\n```c++\nListNode* p = new ListNode\n```\n\n### String\n\n```c++\nstring.length();    //读取字符串长度\n```\n\n### 二分\n\n整数二分有两种区间划分法：\n\n1.mid在左，即分成【l，mid】和【mid + 1，r】，计算mid时向下取整：\n\n```c++\nvector<int> nums(n);\nint l = 0, r = n - 1;\nwhile(l < r)\n{\n\tint mid = l + r >> 1;\n\tif(nums[mid] >= target) r = mid;\n\telse l = mid + 1;\n}\n```\n\n2.mid在右，即分成【l，mid - 1】 和【mid，r】，计算mid时向上取整（需加1）：\n\n```c++\nvector<int> nums(n);\nint l = 0, r = n - 1;\nwhile(l < r)\n{\n\tint mid = l + r + 1 >> 1;\n\tif(nums[mid] <= target) l = mid;\n\telse r = mid - 1;\n}\n```\n\n3.如果想精确的找到某个值，可以：\n\n```c++\nvector<int> nums(n);\nint l = 0, r = n - 1;\nwhile(l <= r)\t//这里一定要是<=，因为很可能在l = r的时候才刚好定位到符合条件的mid\n{\n\tint mid = l + r >> 1;\n    if(nums[mid] == target) return mid;\n    else if(nums[mid] < target) l = mid + 1;\n    else r = mid - 1;\n}\n```\n\n","tags":["tips"],"categories":["Algorithm"]},{"title":"汇编实验：查找电话号码","url":"/2021/11/26/assembly-1/","content":"\n​\t使用汇编语言编写一个能存储电话号码，并拥有查找功能的程序\n\n<!-- more -->\n\n### 实验任务\n\n1）要求建立一个可以存入50项的电话号码表，每项包括人名（20字符）和电话号码（8字符）两部分;\n2）程序可以接受用户输入的人名及相应的电话号码，并把它们加入到电话号码表中;\n3）凡有新的输入后，程序可以按人名对电话号码进行排序;\n4）程序可接收需要查找的电话号码的人名，并从电话号码表中查出电话号码，再在屏幕上以如下格式显示\nname         tel\nxxxxx         xxxxxxxxxx\n\n### 实验思路\n\n​\t\t创建一个db类型的tel_tab来存储电话号码和人名，另创两个label byte inname 和 ipphone来临时存放人名和电话号码，先存进这里面，存好之后再用rep movsb往tel_tab里面搬。\n\n​\t\t查找的时候输入姓名在inname里面，用si指向它；用di指向tel_tab表头，对于tel_tab里面的元素每次都和si里的人名用repe cmpsb比较，若匹配成功说明找到了，输出；匹配失败则add di , 28 指向下一个元素，si重新归位，继续下一次比较，直到找完tel_tab里面所有的东西都没有找到为止返回。\n\n### 源代码\n\n```assembly\ndata    segment\n    count   dw  0\n    tel_tab db  50 dup (20 dup (?) , 8 dup (?))\n    msg1    db  'Input name:', '$'\n    msg2    db  'Input a telephonee number:', '$'\n    msg3    db  'Do you want a telephone number?(Y/N)','$'\n    msg4    db  'name?','$'\n    msg5    db  'name                tel.','$'\n    inname  label   byte\n    inmax   db  21      ;最大长度\n    inact   db  ?       ;数组长度\n    inn     db  21 dup (?)      ;具体内容\n    ipphone label   byte\n    ipmax   db  9\n    ipact   db  ?\n    ipp     db  9 dup (?)\n    cbuf    db  28 dup (?)\ndata    ends   \ncode    segment\n        assume  cs:code, ds:data, es:data\nmain    proc    far\n        push    ds\n        sub     ax , ax\n        push    ax\n        mov     ax , data       \n        mov     ds , ax     ;初始化，ds = data\n        mov     es , ax     ;es = data\n        lea     bx , tel_tab\n        mov     di , bx\nnew:    lea     dx , msg1  ;输出msg1\n        mov     ah , 09h\n        int     21h\n        call    input_name\n        call    crlf\n        mov     al , inact\n        cmp     al , 0   ;什么都不输直接按回车\n        jz      sort     ;相等跳转\n        call    stor_name   ;从data:inn搬到data:tel_tab\n        inc     count\n        lea     dx , msg2   ;输出msg2\n        mov     ah , 09h\n        int     21h\n        call    inphone\n        call    crlf\n        cmp     count , 50\n        jl      new     ;电话号码数量小于50，返回\nsort:\n        call    name_sort\nask_again:\n        call    crlf\n        lea     dx , msg3   ;ds:dx = data:msg3\n        mov     ah , 09h    ;输出字符串\n        int     21h\n        mov     ah , 01h    ;输入单个字符，存在al里\n        int     21h\n        cmp     al , 4eH    ;若输入为N\n        je      return\n        call    crlf\n        cmp     al , 59H    ;若输入为Y\n        jne     ask_again\n        call    crlf\n        lea     dx , msg4   ;输出msg4\n        mov     ah , 09h\n        int     21h\n        call    input_name  ;重新输入名字\n        call    name_search ;查找名字 \n        call    printline\n        jmp     ask_again \nreturn:\n        ret\nmain    endp\ninput_name  proc\n        push    di          ;tel_tab\n        lea     dx , inname\n        mov     ah , 0ah    ;输入到data:inname\n        int     21h\n        lea     di , inn    ;首地址\n        mov     al , inact  ;长度\n        cbw\n        add     di , ax     ;指针指向尾部\n        mov     cx , 21\n        sub     cx , ax     ;得到剩余长度\n        mov     al , 20h    ;ascall码为空格\n        cld                 ;使DF复位，DF = 0,内存地址向高地址增加\n        rep     stosb       ;将AL的值即空格存到ES:DI所指向的位置,清空数组\n        pop     di\n        ret    \ninput_name  endp\nstor_name   proc\n        lea     si , inn\n        mov     cx , 20 ;字符串长度\n        cld\n        rep     movsb   ;把字节从ds:si搬到es:di，从data:inn搬到data:tel_tab\n        ret\nstor_name   endp\ncrlf    proc\n        push    dx\n        push    ax\n        mov     dl , 0dh    ;回车\n        mov     ah , 02h\n        int     21h\n        mov     dl , 0ah\n        mov     ah , 02h    ;换行\n        int     21h\n        pop     ax\n        pop     dx\n        ret\ncrlf    endp\ninphone proc\n        push    di          ;此时di为tel_tab的首地址\n        lea     dx , ipphone    ;输入到ipphone\n        mov     ah , 0ah\n        int     21h\n        lea     di , ipp    ;数组首地址\n        mov     al , ipact  ;数组长度\n        cbw\n        add     di , ax     ;此时di所存为数组尾部地址\n        mov     cx , 9\n        sub     cx , ax     ;求数组剩余空间\n        mov     al , 20h    ;空格\n        cld\n        rep     stosb       ;清空数组\n        pop     di\n        lea     si , ipp\n        mov     cx , 8      ;字符串长度\n        cld \n        rep     movsb       ;把ds:si的东西搬到es:di\n        ret\ninphone endp\nname_sort   proc    ;冒泡排序\n    mov     bx , count\n    dec     bx\ns3:\n    lea     si , tel_tab\n    mov     di , si\n    add     di , 28     ;电话表第二行首地址\n    mov     cx , bx     ;count\ns2:\n    push    si          ;tel_tab地址\n    push    di          ;电话表第二行首地址\n    push    cx          ;count\n    mov     cx , 28\n    cld\n    repe    cmpsb       ;字符串比较\n    pop     cx\n    pop     di\n    pop     si\n    jl      s1          ;若[si] < [di]，跳转\n    call    exchange    ;反之若[si] > [di]交换位置\ns1:\n    add     si , 28     ;指针后移\n    add     di , 28     ;指针后移\n    loop    s2\n    dec     bx\n    jnz     s3          ;count不为零则跳转s3    \n    ret\nname_sort endp\n;----------------------------\nname_search     proc  \n        lea     di , tel_tab ;di指向表头\n        mov     dx , count   ;计数器\nss1:    lea     si , inn     ;si指向要找的名字，每次循环之前把si指针归位\n        dec     dx\n        mov     al , inact   ;只用循环数组长度次数就可以了，如果循环28次的话，假设当前是匹配的\n                             ;那么再循环了inact次之后剩下后面的会因为不匹配而报错 \n        cbw                  ;字节转换成字\n        mov     cx , ax \n        cld\n        push    di\n        repe    cmpsb        ;字符串比较,cx等于0说明匹配\n        pop     di\n        jz      ss2          ;等于0跳s2\n        add     di , 28      ;指针后移\n        cmp     dx , 0\n        jne     ss1          ;如果没找到的话就回去重新找\n        ret \nss2:\n        ret\nname_search     endp\n;----------------------------\nprintline       proc\n        lea     dx , msg5  ;输出msg5\n        mov     ah , 09h\n        int     21h\n        call    crlf\n        push    cx\n        mov     cx , 28\nprintchar:                ;把要输出的字符串拆成28个字符单个输出\n        mov     dl , [di]\n        mov     ah , 02h\n        int     21h\n        add     di , 1\n        loop    printchar\n        pop     cx\n        ret\nprintline       endp\nexchange    proc\t\n    push    cx      ;count\n    push    si      ;tel_tab地址，要被交换的地址\n    push    di      ;下一个号码的地址，另一个要被交换的地址\n    push    ax      ;data\n    push    bx      ;tel_tab\n    mov     ax , si\n    mov     bx , di\n    lea     di , cbuf\n    mov     cx , 28\n    cld\n    rep     movsb   ;把si的东西搬到cbuf\n    mov     di , ax     ;di = si\n    mov     si , bx     ;si = di\n    mov     cx , 28\n    cld\n    rep     movsb   ;把di的东西搬到si\n    lea     si , cbuf\n    mov     bx , di\n    mov     cx , 28\n    cld \n    rep     movsb\n    pop     bx\n    pop     ax\n    pop     di\n    pop     si\n    pop     cx\n    ret\nexchange endp\ncode    ends   \n        end     main\n```\n\n\n\n","tags":["Assembly Language"]},{"title":"Ros2","url":"/2021/09/22/Ros2/","content":"\n<font size = 6>**Ros学习笔记（二）**</font>\n\n​\t\t一些Ros 的命令行\n\n​\t\t// Ctrl + Alt + T 快速打开终端\n\n​\t\t输命令的时候按 Tab 可以自动补全，一些比较复杂的命令，要输参数那种的可以连着按两下 Tab 来补全输参数\n\n<!-- more -->\n\n### 创建工作空间和功能包\n\n​\t\t创建工作空间，catkin_ws是文件夹名字，可以自定义，后面必须要加 /src !!\n\n```\n$ mkdir -p ~/catkin_ws/src\n$ cd ~/catkin_ws/src\n$ catkin_init_workspace\n```\n\n​\t\t编译工作空间\n\n```\n$ cd ~/catkin_ws/\n$ catkin_make\n```\n\n​\t\t设置环境变量，这步很重要，不然等会执行的时候master会找不到publisher文件在哪\n\n```\n$ source devel/setup.bash\n```\n\n​\t\t检查环境变量是否设置ok，输入：\n\n```\n$ echo $ROS_PACKAGE_PATH\n```\n\n​\t\t如果显示如下，就说明设置成功了![](Ros2/ROS_workspace_init.jpg)\n\n------\n\n​\t\t创建功能包，语法格式：\n\n​\t\t$catkin_create_pkg <package_name> [depend1] [depend2] [depend3]\n\n```\n$ cd ~/catkin_ws/src\n$ catkin_create_pkg test_pkg std_msgs rospy roscpp\n```\n\n​\t\t编译功能包\n\n```\n$ cd ~/catkin_ws\n$ catkin_make\n```\n\n​\t\t之后就启动ros，然后用rosrun运行功能包\n\n```\n$ rosrun <功能包文件夹名字> <cpp/py 文件名>\n```\n\n------\n\n### 自定义话题\n\n在功能包里，新建一个msg文件夹来存放msg文件\t\t\n\n![](Ros2/ros_yolo.jpg)\n\n新建一个.msg文件，类似这种\n\n![](Ros2/msg.jpg)\n\n之后在功能包里的package.xml里加\n\n```xml\n<build_depend>message_generation</build_depend>\n<exec_depend>message_runtime</exec_depend>\n```\n\n![](Ros2/package.jpg)\n\n在功能包的Cmakelist.xml里3个部分分别添加：\n\n```xml\nfind_package(\n...message_generation\n)\n```\n\n![](Ros2/cmakelist1.jpg)\n\n```xml\nadd_message_files(\n   FILES\n   Message1.msg\n   Message2.msg\n )\n```\n\n![](Ros2/cmakelist2.png)\n\n```xml\ncatkin_package(\n...message_runtime...\n)\n```\n\n![](Ros2/cmakelist3.png)\n\n然后catkin_make编译，编译成功后会在 工作空间的根目录\\devel\\include\\功能包名字 里面发现.h文件\n\n![](Ros2/.h.jpg)\n\n\n\n\n\n------\n\n### 话题记录和话题复现\n\n​\t\t首先启动ros\n\n```\n$ roscore\n```\n\n​\t\t话题记录，输入这个命令后，会在默认位置 home生成一个cmd_record.bag文件，这个文件记录了开启后的话题操作，可以用来复现\n\n```\n$ rosbag record -a -O(大写的o) cmd_record\n```\n\n​\t\t话题复现，就是把刚刚保存的数据复现出来\n\n```\n$ rosbag play cmd_record.bag\n```\n\n------\n\n### 参数配置命令行\n\n​\t\tROS Master里面有一个参数服务器Parameter Server，相当于一个全局字典，里面的值（如：/robot_name : \"robot1\"）任何一个Node都可以访问使用\n\n​\t\t列出当前参数列表\n\n```\n$ rosparam list\n```\n\n​\t\t显示某个参数的值\n\n```\n$ rosparam get xxx\n```\n\n​\t\t改变某个参数的值\n\n```\n$ rosparam set xxx new_value\n```\n\n​\t\t删除某个参数\n\n```\n$ rosparam delete xxx\n```\n\n​\t\t保存当前参数列表到某个文件，此文件的后缀是yaml，会自动生成在当前终端的默认路径下\n\n```\n$ rosparam dump file_name.yaml\n```\n\n​\t\t从某个文件读取参数列表\n\n```\n$ rosparam load file_name.yaml\n```\n\n","tags":["Ros"],"categories":["Ros"]},{"title":"基础算法：数论","url":"/2021/09/17/Math/","content":"\n一些数论的基础算法\n\n<!-- more -->\n\n### 一、质数\n\n​\t\t质数的分解有三种方法\n\n#### 1.试除法 O(sqrt(n))\n\n​\t\t没啥好说的，就暴力。\n\n```c++\nbool judge(int x)\n{\n    if(x == 1) return false;\n    for(int i = 2; i <= x / i; i ++)\n    {\n        if(x % i == 0)\n            return false;\n    }\n    return true;\n}\n```\n\n#### 2.朴素筛法 O(n * log n)\n\n​\t\t算法思想就是从i = 2开始，每次都把 i 的倍数给标记（筛）掉，这些数都是合数。只有当 i 为质数时才进行筛的操作，i 是合数直接continue\n\n```cpp\nint primes[N], cnt;  //primes[]拿来存质数， cnt是质数的个数\nbool book[N]; //book用来标记一个数是否是质数,若book[i] = true，说明i不是质数\nvoid divide(int x)\n{\n    for(int i = 2; i <= n; i ++) \n    {\n        if(book[i]) continue;  \n        primes[cnt ++] = i;\t//把质数保存下来\n        for(int j = i; j <= n; j += i) //i从2开始循环，第一轮会把所有2的倍数都筛掉；第二轮i=3时会把所有3的倍数都筛掉并标记，这样一直循环到n，没被标记过的数就一定是质数\n            book[j] = true;\n    }\n    return;\n}\n```\n\n#### 3.线性筛法 O(n * log log n)\n\n​\t\t线性筛法能保证一个合数只会被筛一次，这样时间复杂度就降下来了\n\n​\t\t首先是唯一分解定理：任何一个合数N，都可以被分解成有限个质数的乘积。设一个合数 x ，x必定存在一个最小质因数t，且一定有 x/t < n，而 i 从2遍历到n，因此必定会出现 t * i = x的情况出现，故任何一个小于等于n的合数都会被标记。\n\n​\t\t再证明primes[j] 一定是 primes[j] * i 的最小质因子：\n\n​\t\t1.若 i % primes[j] == 0， 那么说明primes[j] 一定是 i 的最小质因子，也一定是primes[j] * i 的最小质因子\n\n​\t\t2.若 i % primes[j] != 0，由于 primes[j] 是从小到大遍历的质数，那么 i 的最小质因子一定大于  primes[j] 。所以 primes[j] * i 的最小质因子一定是 primes[j]\n\n```cpp\nint primes[N], cnt; \nbool book[N];\nvoid divide(int x)\n{\n    for(int i = 2; i <= n; i ++)  \n    {\n        if(!book[i]) primes[cnt ++] = i;\n        for(int j = 0; primes[j] <= n / i; j ++)//从小到大遍历所有已经存好的质数\n        {\n            book[primes[j] * i] = true; //要求primes[j] * i < n\n            if(i % primes[j] == 0) break; //如果不及时结束的话，会把本该后面筛掉的数提前筛掉，就会导致一个数被筛多次而超时\n        }\n    }\n    return;\n}\n```\n\n### 二、约数\n\n​\t\t求约数的话没有什么特别好的算法，就只有暴力试除法：\n\n```c++\nvector<int> divide(int x)\n{\n    vector<int> res;\n    for(int i = 1; i <= n / i; i ++)\n        if(x % i == 0)\n        {\n            res.push_back(i);\n            if(x / i != i)  //避免出现res里面放两个平方根的情况\n                res.push_back(x / i);\n        }\n    sort(res.begin(), res.end());  //排序一下\n    return res;\n}\n```\n\n​\t\t此外有两个公式，可以很快的求约数的个数和约数之和：\n\n![](Math/yueshu.jpg)\n\n​\t\t对于约数之和公式，有一个很好用的小模版：\n\n","tags":["Number theory"],"categories":["Algorithm"]},{"title":"STL","url":"/2021/09/08/STL/","content":"\n关于一些cpp STL库函数的用法\n\n万能头文件 ： #include<bits/stdc++.h>\n\n<!-- more -->\n\n### unordered_map\n\n------\n\n哈希表，也可以当字典来用\n\n比如：\n\n```c++\nunordered_map<string, int> ss;\nss[\"laoyin\"] = 666;\n```\n\n这时候 cout << ss[\"laoyin\"] 就会输出666\n\n也可以：\n\n```cpp\nss.insert({\"laoyin\", 666});\n```\n\n如果想要哈希表里面的值（即ss[\"laoyin\"]）迭代增加或者减小的话，可以直接：\n\n```c++\nss[\"laoyin\"] ++;\n```\n\n遍历ss里面的值的话，可以\n\n```c++\nint res = 0;\nfor(auto& [k, v] : ss) res = max(res, v);\n```\n\n### unordered_set\n\n------\n\n和set一样，一个不允许有重复元素的容器\n\n```c++\nunordered_set<int> ss;\nss.insert(1);\ncout << ss.count(1) << endl;  //输出1\n```\n\n可以用 ss.count(a) 来判断set中是否存在a，由于set中不允许出现重复元素，因此返回值只有0 和 1。\n\n### vector\n\n------\n\n类似一个数组\n\n```cpp\nvector<int> a;\na.push_back(666);\n```\n\n想给vector排序的话可以：\n\n```c++\nsort(a.begin(), a.end());\n```\n\n遍历：\n\n```c++\nfor(auto t : a) cout << t << \" \";\n```\n\n判断两个vector是否相等可以直接：\n\n```c++\nvector<int> a;\nvector<int> b;\nif(a == b) \n\t...\n```\n\n此外，vector中clear的作用只是将size置0，原来有的元素还是会在里面：\n\n```c++\nvector<int> a(30);  //预分配30个空间给a\na[1] = 1;\na.clear();    //clear完后a[1]还是等于1。换成erase也是一样的，a[1]还是1\n```\n\n如果想将vector置0，可以用assign:\n\n```c++\na.assign(26, 0); \t//将前26个元素全部置0\n```\n\n","tags":["STL"]},{"title":"基础算法：搜索和图论","url":"/2021/07/25/Graph/","content":"\n一些图论的基础算法\n\n<!-- more -->\n\n## Data struct : 邻接表\n\n```cpp\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[M], ne[M], idx; //h[]是队头指针，e[]是节点的值，ne[]是指针，N是点数，M是边数\n\t\n// 添加一条边a->b\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);\n\n//遍历：\nfor(int i = h[a]; i != -1; i = ne[i]) //i是指针，具体的值要e[i]来读取一下\n\tint b = e[i];\n\t...\n```\n\n![](Graph/data_struct.jpg)\n\n新的指针 ne[ idx ] 指向原来队头的下一个节点，即c，然后队头指向新插入的节点b，完成链表头插过程\n\n### 树的重心（dfs）\n\n![](Graph/树的重心1.jpg)\n\n![](Graph/树的重心2.jpg)\n\n来源Acwing模板题：https://www.acwing.com/problem/content/description/848/\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <queue>\nusing namespace std;\nconst int N = 100010;\nint e[N * 2], h[N], ne[N * 2], idx;  //因为是无向图，每个点要连两遍，所以要2*N\nint n, ans = N;  //ans为最后结果\nint book[N];\t//标记某个点是否被读取过\nvoid add(int a, int b)   //a -> b\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;\n}\nint dfs(int u)   //返回以u为根节点的子树节点数\n{\n    book[u] = 1;\n    \n    int sum = 1, res = 0;  //sum为返回值，根节点也算一个所以初始值为1，res为删掉u后最大连通块的节点数量\n    for(int i = h[u]; i != -1; i = ne[i])    //邻接表遍历\n    {\n        int j = e[i];\n        if(!book[j])\n        {\n            int s = dfs(j);\n            res = max(res, s);\n            sum += s;\n        }\n    }\n    res = max(res, n - sum);  //除了u这棵子树以外的点组成的连通分支\n    ans = min(ans, res);\n    return sum;\n\n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n;\n    for(int i = 1; i <= n - 1; i ++)\n    {\n        int a, b;\n        cin >> a >> b;\n        add(a, b), add(b, a);\n    }\n    dfs(1); //这里只用从1~n任意一个点开始遍历即可，也可以换成dfs(n)。比如说测试用例，从1进去后会再dfs到1的相邻节点2,4,7因此会执行dfs(2),虽然1被标记过了在执行dfs(2)的时候读取不到，但是不用读取也能计算出结果，因为在dfs的最后会把除了u这棵子树以外的点组成的连通分支和目前的res再进行一次比较，所以dfs(2)时134679这个连通分支虽然读取不到，但是也能算出来这个分支节点个数并且和ans比较\n    cout << ans;\n    return 0;\n}\n```\n\n## 朴素Dijkstra\n\n​\t时间复杂度为O(n^2 + m)\n\n```cpp\nint g[N][N];  // 存储每条边\nint dist[N];  // 存储1号点到每个点的最短距离\nbool st[N];   // 存储每个点的最短路是否已经确定\n\n// 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    for (int i = 0; i < n - 1; i ++ )\n    {\n        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j <= n; j ++ )\n            if (!st[j] && (t == -1 || dist[t] > dist[j]))\n                t = j;\n\n        // 用t更新其他点的距离\n        for (int j = 1; j <= n; j ++ )\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n\n        st[t] = true;\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\n作者：yxc\n链接：https://www.acwing.com/blog/content/405/\n来源：AcWing\n```\n\n### 堆优化Dijkstra\n\n**例题**：Dijkstra求最短路 II \n\n![](Graph/迪杰斯特拉1.jpg)\n\n![](Graph/迪杰斯特拉2.jpg)\n\n来源Acwing模板题：https://www.acwing.com/problem/content/852/\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 150010;\ntypedef pair<int, int> PII; //first存储距离，second存节点编号\nint e[N], ne[N], d[N], h[N], w[N];\nint book[N];\t//book[i] = 1表示已经找到起点到i的最短路\nint n, m, idx;\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n}\nint djs()\n{\n    memset(d, 0x3f, sizeof d);\n    d[1] = 0;\n    \n    priority_queue<PII, vector<PII>, greater<PII>> heap;  //greater参数生成小根堆\n    heap.push({0, 1});\n    while(!heap.empty())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, dis = t.first;\n        if(book[ver]) continue;\n        book[ver] = 1;\n\n        for(int i = h[ver]; i != -1; i = ne[i]) \n        {\n            int j = e[i];\n            if(dis + w[i] < d[j])\n            {\n                d[j] = dis + w[i];\n                heap.push({d[j], j});\n            }\n        } \n        \n    }\n    if(d[n] == 0x3f3f3f3f) return -1; //若从起点到n的最短路不存在\n    else return d[n];\n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        add(a, b, c);\n    }\n   \n    int t = djs();\n    cout << t << endl;\n    return 0;\n}\n```\n\n## Bellman_Ford\n\n时间复杂度：O(nm)\n\n```cpp\nint n, m;       // n表示点数，m表示边数\nint dist[N];        // dist[x]存储1到x的最短路距离\n\nstruct Edge     // 边，a表示出点，b表示入点，w表示边的权重\n{\n    int a, b, w;\n}edges[M];\n\n// 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i = 0; i < n; i ++ )//n表示从1到n最多经过n条边\n    {\n        for (int j = 0; j < m; j ++ )\n        {\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            if (dist[b] > dist[a] + w)\n                dist[b] = dist[a] + w;\n        }\n    }\n\n    if (dist[n] > 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n}\n\n作者：yxc\n链接：https://www.acwing.com/blog/content/405/\n来源：AcWing\n```\n\n## SPFA\n\n### 求最短路\n\n​\t其实就是用队列优化的bellman_ford，简单点说就是在遍历的时候，只遍历d[]值变小的点，因为d[]值不变的点必定不会对结果有影响。\n\n​\t只要图里没有负权环就可以用，一般O(n)，最坏O(nm)，其实一般负权图都不会有负环。spfa其实对于很多正权图也是很适用的，（只要不被出题人卡\n\n​\t**例题**：SPFA求最短路   来源ACwing模板题：https://www.acwing.com/problem/content/description/853/\n\n![](Graph/SPFA1.jpg)\n\n![](Graph/SPFA2.jpg)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint e[N], ne[N], h[N], w[N], d[N];\nint book[N];    //book[i] = 1 表示i已经在队列里，等于0表示不在队列里\nint n, m, idx;\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n}\nint spfa()\n{\n    memset(d, 0x3f, sizeof d);\n    d[1] = 0;       //初始化\n\n    queue<int> q;\n    q.push(1);\n    book[1] = 1;\n    while(!q.empty())\n    {\n        auto t = q.front();\n        q.pop();\n        book[t] = 0;\n        \n        for(int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if(d[t] + w[i] < d[j])  //若经过t到j的距离比直接到j的距离要短\n            {\n                d[j] = d[t] + w[i];\n                if(!book[j])  //若j不在队列里\n                {\n                    q.push(j);\n                    book[j] = 1;\n                }\n            }\n        }\n    }\n    if(d[n] == 0x3f3f3f3f) return -1;\n    else return d[n]; \n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        add(a, b, c);\n    }\n    int t = spfa();\n    if(t == -1) cout << \"impossible\" << endl;\n    else cout << t << endl;\n    return 0;\n}\n```\n\n### 找负权环\n\n​\t判断一个图中是否有负权回路一般都用SPFA，做法是在代码中加入一个cnt[]数组，cnt[i] 存放1到 i 的最短路上经过的边数。若cnt[i] >= n，则这条路上一定有n+1或以上个点，就必定有两个或以上重复点，又由于是最短路上的，所以必定存在负权环。\n\n​\t代码实现，在上方代码spfa函数while里的for循环里的if下面插入:\n\n```cpp\n\tcnt[j] = cnt[t] + 1;   \n\tif(cnt[j] >= n) return true;\n```\n\n​\t同时初始时要把所有的点都放进队列：\n\n```cpp\nfor(int i = 1; i <= n; i ++)\n    {\n        q.push(i);\n        book[i] = 1;\n    }\n```\n\n​\t如果还是只放起点的话，若是图中的负权环是起点到不了的，就找不到了。因此干脆就把所有的点都放进去，这样不管负权环在哪，只要存在就一定能找得到。\n\n## Floyd\n\n​\tFloyd的原理是动态规划：d[k,i,j]表示从i到j只经过1~k号点的最短路的距离，d[k,i,j] = min(d[k,i,j], d[k-1,i,k] + d[k-1,k,j])。然后第一维可以略去，就是下面的形式\n\n```cpp\nfor(int k = 1; k <= n; k ++)\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n```\n\n​\t最后所得d中d[ i ] [ j ]就表示i~j最短距离\n\n## 最小生成树\n\n### Prim\n\n​\t朴素Prim时间复杂度为O(n^2)，堆优化为O(m logn)\n\n​\t从图中任意一点u开始，记集合U = {u}，每次找到一个离集合最近的、不在集合当中的点，并入集合，直到所有点都被并入集合。\n\n![](Graph/Prim.jpg)\n\n<center>\n    <font size = 2>\n    图片来源：清华大学教程《数据结构》(严蔚敏、吴伟民编著) 插图\n</center>\n\n### Kruskal\n\n​\t时间复杂度为O(m logm)\n\n​\t先将所有边按从小到大的顺序排序，之后每次选择边权最小且边的两点不在同一连通块的边，加入集合，直到所有点都在集合内。最后所得集合就是最小生成树。\n\n![](Graph/Kruskal.jpg)\n\n<center>\n    <font size = 2>\n    图片来源：清华大学教程《数据结构》(严蔚敏、吴伟民编著) 插图\n</center>\n\n\n## 染色法判断二分图\n\n​\t定理：一个图是二分图的**充要**条件是，该图没有**奇数环**。\n\n​\t因此可以用染色法来判断二分图。具体做法是从一个没有颜色的点开始染色，例如用黑白两色来染。某一起始点 x 染上黑色后，所有的邻点都染上白色，x的邻点的邻点又染黑色，直到所有的点都有颜色，如果没有出现冲突的情况，就说明这个图是二分图。该算法的时间复杂度为O(n + m)\n\n​\t**例题**：染色法判断二分图\t来源Acwing模板题：https://www.acwing.com/problem/content/862/\n\n![](Graph/染色法.jpg)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100010, M = 200010;\nint h[N], e[M], ne[M];\t\nint color[N];  //存放节点的颜色，1是一种颜色，2是另一种颜色\nint n, m, idx;\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;\n}\nbool dfs(int u, int c)\n{\n    color[u] = c;   //染色\n    for(int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if(!color[j])   //若当前点没有颜色\n        {\n            if(!dfs(j, 3 - c)) return false;  //dfs(j, 3-c)=false表示对j染色出现矛盾\n        }\n        else if(color[j] == c) return false;\n    }\n    return true;\n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int a, b;\n        cin >> a >> b;\n        add(a, b), add(b, a);   //无向图，存两条边\n    }\n    int flag = 1;\n    for(int i = 1; i <= n; i ++) //遍历所有点\n    {\n        if(!color[i])  //若该点没有颜色\n        {\n            if(!dfs(i, 1))\t//若对i点染色的过程出现了矛盾\n            {\n                flag = 0;\t//说明该图不是二分图\n                break;\n            }\n        }\n        \n    }\n    if(flag) puts(\"Yes\");\n    else puts(\"No\");\n}\n```\n\n## 匈牙利算法\n\n​\t匈牙利算法的作用是返回一个二分图的最大匹配。举个例子，令一个二分图分成a和b两个部分。从a部分开始遍历（从b部分开始也可以），如a[ i ]找和其相连的b部分的对应点b[ j ]形成配对。如果出现冲突，也就是b[ j ]已近和其他的点a[ x ]配对了，那就反过来看看a[ x ]能不能和别的配对，找个下家，如果可以的话b[ j ]就可以空出来和a[ i ]配对了。\n\n​\t时间复杂度为O(mn)，实际运行时间一般远小于O(mn)。\n\n```\n\t二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点（没有任何一个点在多条边上，也就是说一个点只和一条边配对），则称 M 是一个匹配。\n\t二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。\n```\n\n例题：二分图的最大匹配\t来源Acwing模板题：https://www.acwing.com/problem/content/863/\n\n![](Graph/匈牙利算法1.jpg)\n\n![](Graph/匈牙利算法2.jpg)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 510, M = 100010;\nint h[N], e[M], ne[M];\nint match[N];   //match[i]是和b[i]配对的a部分中的某个点\nint book[N];    //book[]的作用是在想办法腾出位置（回溯）的时候，防止回溯过程中又读取到这个点。比如说现在a[i]想和b[i]配对，但是b[i]在之前已经和a[j]配对了，于是看看能不能让a[j]和另一个配对把b[i]的位置腾出来，这里就需要find(a[j])。为了防止find(a[j])的时候a[j]又读取到b[i]，就要来一个book，先帮a[i]“占位置”\nint n1, n2, m, idx;\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;\n}\nbool find(int x)     //在b部分中找和x配对的点，找得到返回true\n{\n    for(int i = h[x]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if(!book[j])\n        {\n            book[j] = 1;\n            if(match[j] == 0 || find(match[j]))  //若当前j点没有和a部分的点匹配或者能把j的位置腾出来\n            {\n                match[j] = x;\n                return true;\n            }\n        }  \n    }\n    return false;\n}\nint main()\n{\n    memset(h, -1, sizeof h);\n    cin >> n1 >> n2 >> m;\n    for(int i = 1; i <= m; i ++)\n    {\n        int a, b;\n        cin >> a >> b;\n        add(a, b);  //只用连一条边就好了，因为整个算法过程都只遍历从a到b的边，不会用到b到a\n    }\n    int res = 0;\n    for(int i = 1; i <= n1; i ++)  //任选两个部分其中一个开始遍历\n    {\n        memset(book, 0, sizeof book);\n        if(find(i))\n            res ++;\n    }\n    cout << res << endl;\n    return 0;\n}\n```\n\n\n\n","tags":["Graph"],"categories":["Algorithm"]},{"title":"Ros","url":"/2021/07/20/Ros1/","content":"\n## Ros学习笔记（一）\n\n一些Linux基础命令\n\n<!-- more -->\n\n### Linux基础命令\n\n##### 快捷键：Ctrl+Alt+t 打开终端\n\n```\n$ pwd  \t\t//显示当前终端工作目录的绝对路径\n```\n\n```\n$ cd /home/   //进入home\n$ cd ..      //返回上一级目录\n```\n\n​\t![](Ros1/cd.jpg)\n\n```\n$ mkdir (文件夹名)    //make direction:创建一个新的文件夹\n$ ls               //list:查看当前路径下有哪些文件\n```\n\n```\n$ touch test\t\t//在当前路径新建一个名为test的文件\n$ mv test /home/laoyin/\t\t//move:把test剪切到目标位置/home/laoyin/下\n$ cp test /home/laoyin/(new_name)\t//copy:把test复制到目标位置下，同时给新的test改个名字，也可以什么都不加\n```\n\n```\n$ rm test\t//remove:删除当前路径下的test文件\n$ rm -r test\t//删除当前路径下的test文件夹\n```\n\n```\n$ sudo \t\t//提升当前用户的权限\n```\n\n### C++ & Python\n\n首先先安装c++和python的编译器\n\n```\n$ sudo apt-get install g++\t\t//cpp\n$ sudo apt-get install python\t//python\n```\n\nc++的代码执行之前要先在终端里面编译，然后才能用终端执行\n\n```\n$ g++ xxx.cpp -o xxx\n```\n\n这时候就会生成一个名为“xxx”的可执行文件\n\n```\n$ ./xxx\n```\n\n然后就用“./”（运行某个程序或者脚本），就可以运行了\n\npython不用编译，直接执行就行了\n\n```\n$ python xxx.py\n```\n\n","tags":["Ros"],"categories":["Ros"]},{"title":"序章","url":"/2021/07/17/starts/","content":"\n<center>\n<font size = 6.5>\n    「Hello World」\n\n<center><font size = 3>欢迎来到我的小屋。\n\n<center>平时会写一写一些学到的东西，如果喜欢的话谢谢欣赏\n\n------\n\n<center>除了打代码，平时还喜欢看点历史，偶尔也会写个一两篇，欢迎关注我的历史小屋\n\n![](starts/small.jpg)\n\n<center>老鹰的历史小屋\n<!-- more -->"}]