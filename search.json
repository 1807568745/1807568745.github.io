[{"title":"基础算法：搜索和图论","url":"/2021/07/25/Graph/","content":"<p>一些图论的基础算法</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Data-struct-邻接表\"><a href=\"#Data-struct-邻接表\" class=\"headerlink\" title=\"Data struct : 邻接表\"></a>Data struct : 邻接表</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> h[N], e[M], ne[M], idx; <span class=\"comment\">//h[]是队头指针，e[]是节点的值，ne[]是指针，N是点数，M是边数</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">// 添加一条边a-&gt;b</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[a]; i != <span class=\"number\">-1</span>; i = ne[i]) <span class=\"comment\">//i是指针，具体的值要e[i]来读取一下</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = e[i];</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/07/25/Graph/data_struct.jpg\"></p>\n<p>新的指针 ne[ idx ] 指向原来队头的下一个节点，即c，然后队头指向新插入的节点b，完成链表头插过程</p>\n<h3 id=\"树的重心（dfs）\"><a href=\"#树的重心（dfs）\" class=\"headerlink\" title=\"树的重心（dfs）\"></a>树的重心（dfs）</h3><p><img src=\"/2021/07/25/Graph/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%831.jpg\"></p>\n<p><img src=\"/2021/07/25/Graph/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%832.jpg\"></p>\n<p>来源Acwing模板题：<a href=\"https://www.acwing.com/problem/content/description/848/\">https://www.acwing.com/problem/content/description/848/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">100010</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> e[N * <span class=\"number\">2</span>], h[N], ne[N * <span class=\"number\">2</span>], idx;  <span class=\"comment\">//因为是无向图，每个点要连两遍，所以要2*N</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n, ans = N;  <span class=\"comment\">//ans为最后结果</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> book[N];\t<span class=\"comment\">//标记某个点是否被读取过</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span>   <span class=\"comment\">//a -&gt; b</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span>   <span class=\"comment\">//返回以u为根节点的子树节点数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    book[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">1</span>, res = <span class=\"number\">0</span>;  <span class=\"comment\">//sum为返回值，根节点也算一个所以初始值为1，res为删掉u后最大连通块的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[u]; i != <span class=\"number\">-1</span>; i = ne[i])    <span class=\"comment\">//邻接表遍历</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!book[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = <span class=\"built_in\">dfs</span>(j);</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, s);</span><br><span class=\"line\">            sum += s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res = <span class=\"built_in\">max</span>(res, n - sum);  <span class=\"comment\">//除了u这棵子树以外的点组成的连通分支</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">min</span>(ans, res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b), <span class=\"built_in\">add</span>(b, a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>); <span class=\"comment\">//这里只用从1~n任意一个点开始遍历即可，也可以换成dfs(n)。比如说测试用例，从1进去后会再dfs到1的相邻节点2,4,7因此会执行dfs(2),虽然1被标记过了在执行dfs(2)的时候读取不到，但是不用读取也能计算出结果，因为在dfs的最后会把除了u这棵子树以外的点组成的连通分支和目前的res再进行一次比较，所以dfs(2)时134679这个连通分支虽然读取不到，但是也能算出来这个分支节点个数并且和ans比较</span></span><br><span class=\"line\">    cout &lt;&lt; ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"朴素Dijkstra\"><a href=\"#朴素Dijkstra\" class=\"headerlink\" title=\"朴素Dijkstra\"></a>朴素Dijkstra</h2><p>​    时间复杂度为O(n^2 + m)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> g[N][N];  <span class=\"comment\">// 存储每条边</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dist[N];  <span class=\"comment\">// 存储1号点到每个点的最短距离</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> st[N];   <span class=\"comment\">// 存储每个点的最短路是否已经确定</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i ++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = <span class=\"number\">-1</span>;     <span class=\"comment\">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++ )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!st[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[t] &gt; dist[j]))</span><br><span class=\"line\">                t = j;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 用t更新其他点的距离</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++ )</span><br><span class=\"line\">            dist[j] = <span class=\"built_in\">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class=\"line\"></span><br><span class=\"line\">        st[t] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dist[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：yxc</span><br><span class=\"line\">链接：https:<span class=\"comment\">//www.acwing.com/blog/content/405/</span></span><br><span class=\"line\">来源：AcWing</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"堆优化Dijkstra\"><a href=\"#堆优化Dijkstra\" class=\"headerlink\" title=\"堆优化Dijkstra\"></a>堆优化Dijkstra</h3><p><strong>例题</strong>：Dijkstra求最短路 II </p>\n<p><img src=\"/2021/07/25/Graph/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%891.jpg\"></p>\n<p><img src=\"/2021/07/25/Graph/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%892.jpg\"></p>\n<p>来源Acwing模板题：<a href=\"https://www.acwing.com/problem/content/852/\">https://www.acwing.com/problem/content/852/</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">150010</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; PII; <span class=\"comment\">//first存储距离，second存节点编号</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> e[N], ne[N], d[N], h[N], w[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> book[N];\t<span class=\"comment\">//book[i] = 1表示已经找到起点到i的最短路</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">djs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(d, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> d);</span><br><span class=\"line\">    d[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  <span class=\"comment\">//greater参数生成小根堆</span></span><br><span class=\"line\">    heap.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!heap.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = heap.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        heap.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ver = t.second, dis = t.first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(book[ver]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        book[ver] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[ver]; i != <span class=\"number\">-1</span>; i = ne[i]) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis + w[i] &lt; d[j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                d[j] = dis + w[i];</span><br><span class=\"line\">                heap.<span class=\"built_in\">push</span>(&#123;d[j], j&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">//若从起点到n的最短路不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> d[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b, c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"built_in\">djs</span>();</span><br><span class=\"line\">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman_Ford\"></a>Bellman_Ford</h2><p>时间复杂度：O(nm)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n, m;       <span class=\"comment\">// n表示点数，m表示边数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dist[N];        <span class=\"comment\">// dist[x]存储1到x的最短路距离</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>     // 边，<span class=\"title\">a</span>表示出点，<span class=\"title\">b</span>表示入点，<span class=\"title\">w</span>表示边的权重</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, w;</span><br><span class=\"line\">&#125;edges[M];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bellman_ford</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++ )<span class=\"comment\">//n表示从1到n最多经过n条边</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class=\"line\">                dist[b] = dist[a] + w;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dist[n] &gt; <span class=\"number\">0x3f3f3f3f</span> / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：yxc</span><br><span class=\"line\">链接：https:<span class=\"comment\">//www.acwing.com/blog/content/405/</span></span><br><span class=\"line\">来源：AcWing</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h2><h3 id=\"求最短路\"><a href=\"#求最短路\" class=\"headerlink\" title=\"求最短路\"></a>求最短路</h3><p>​    其实就是用队列优化的bellman_ford，简单点说就是在遍历的时候，只遍历d[]值变小的点，因为d[]值不变的点必定不会对结果有影响。</p>\n<p>​    只要图里没有负权环就可以用，一般O(n)，最坏O(nm)，其实一般负权图都不会有负环。spfa其实对于很多正权图也是很适用的，（只要不被出题人卡</p>\n<p>​    <strong>例题</strong>：SPFA求最短路   来源ACwing模板题：<a href=\"https://www.acwing.com/problem/content/description/853/\">https://www.acwing.com/problem/content/description/853/</a></p>\n<p><img src=\"/2021/07/25/Graph/SPFA1.jpg\"></p>\n<p><img src=\"/2021/07/25/Graph/SPFA2.jpg\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">100010</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> e[N], ne[N], h[N], w[N], d[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> book[N];    <span class=\"comment\">//book[i] = 1 表示i已经在队列里，等于0表示不在队列里</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(d, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> d);</span><br><span class=\"line\">    d[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;       <span class=\"comment\">//初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\">    queue&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    book[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        book[t] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[t]; i != <span class=\"number\">-1</span>; i = ne[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[t] + w[i] &lt; d[j])  <span class=\"comment\">//若经过t到j的距离比直接到j的距离要短</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                d[j] = d[t] + w[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!book[j])  <span class=\"comment\">//若j不在队列里</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(j);</span><br><span class=\"line\">                    book[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> d[n]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b, c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = <span class=\"built_in\">spfa</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t == <span class=\"number\">-1</span>) cout &lt;&lt; <span class=\"string\">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"找负权环\"><a href=\"#找负权环\" class=\"headerlink\" title=\"找负权环\"></a>找负权环</h3><p>​    判断一个图中是否有负权回路一般都用SPFA，做法是在代码中加入一个cnt[]数组，cnt[i] 存放1到 i 的最短路上经过的边数。若cnt[i] &gt;= n，则这条路上一定有n+1或以上个点，就必定有两个或以上重复点，又由于是最短路上的，所以必定存在负权环。</p>\n<p>​    代码实现，在上方代码spfa函数while里的for循环里的if下面插入:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">cnt[j] = cnt[t] + <span class=\"number\">1</span>;   </span><br><span class=\"line\"><span class=\"keyword\">if</span>(cnt[j] &gt;= n) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>​    同时初始时要把所有的点都放进队列：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        book[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    如果还是只放起点的话，若是图中的负权环是起点到不了的，就找不到了。因此干脆就把所有的点都放进去，这样不管负权环在哪，只要存在就一定能找得到。</p>\n<h2 id=\"Floyd\"><a href=\"#Floyd\" class=\"headerlink\" title=\"Floyd\"></a>Floyd</h2><p>​    Floyd的原理是动态规划：d[k,i,j]表示从i到j只经过1~k号点的最短路的距离，d[k,i,j] = min(d[k,i,j], d[k-1,i,k] + d[k-1,k,j])。然后第一维可以略去，就是下面的形式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; k ++)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++)</span><br><span class=\"line\">\t\t\td[i][j] = <span class=\"built_in\">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br></pre></td></tr></table></figure>\n\n<p>​    最后所得d中d[ i ] [ j ]就表示i~j最短距离</p>\n<h2 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h2><h3 id=\"Prim\"><a href=\"#Prim\" class=\"headerlink\" title=\"Prim\"></a>Prim</h3><p>​    朴素Prim时间复杂度为O(n^2)，堆优化为O(m logn)</p>\n<p>​    从图中任意一点u开始，记集合U = {u}，每次找到一个离集合最近的、不在集合当中的点，并入集合，直到所有点都被并入集合。</p>\n<p><img src=\"/2021/07/25/Graph/Prim.jpg\"></p>\n<center>\n    <font size=\"2\">\n    图片来源：清华大学教程《数据结构》(严蔚敏、吴伟民编著) 插图\n</font></center>\n\n<h3 id=\"Kruskal\"><a href=\"#Kruskal\" class=\"headerlink\" title=\"Kruskal\"></a>Kruskal</h3><p>​    时间复杂度为O(m logm)</p>\n<p>​    先将所有边按从小到大的顺序排序，之后每次选择边权最小且边的两点不在同一连通块的边，加入集合，直到所有点都在集合内。最后所得集合就是最小生成树。</p>\n<p><img src=\"/2021/07/25/Graph/Kruskal.jpg\"></p>\n<center>\n    <font size=\"2\">\n    图片来源：清华大学教程《数据结构》(严蔚敏、吴伟民编著) 插图\n</font></center>\n\n\n<h2 id=\"染色法判断二分图\"><a href=\"#染色法判断二分图\" class=\"headerlink\" title=\"染色法判断二分图\"></a>染色法判断二分图</h2><p>​    定理：一个图是二分图的<strong>充要</strong>条件是，该图没有<strong>奇数环</strong>。</p>\n<p>​    因此可以用染色法来判断二分图。具体做法是从一个没有颜色的点开始染色，例如用黑白两色来染。某一起始点 x 染上黑色后，所有的邻点都染上白色，x的邻点的邻点又染黑色，直到所有的点都有颜色，如果没有出现冲突的情况，就说明这个图是二分图。该算法的时间复杂度为O(n + m)</p>\n<p>​    <strong>例题</strong>：染色法判断二分图    来源Acwing模板题：<a href=\"https://www.acwing.com/problem/content/862/\">https://www.acwing.com/problem/content/862/</a></p>\n<p><img src=\"/2021/07/25/Graph/%E6%9F%93%E8%89%B2%E6%B3%95.jpg\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">100010</span>, M = <span class=\"number\">200010</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> h[N], e[M], ne[M];\t</span><br><span class=\"line\"><span class=\"keyword\">int</span> color[N];  <span class=\"comment\">//存放节点的颜色，1是一种颜色，2是另一种颜色</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    color[u] = c;   <span class=\"comment\">//染色</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[u]; i != <span class=\"number\">-1</span>; i = ne[i])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!color[j])   <span class=\"comment\">//若当前点没有颜色</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">dfs</span>(j, <span class=\"number\">3</span> - c)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  <span class=\"comment\">//dfs(j, 3-c)=false表示对j染色出现矛盾</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(color[j] == c) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b), <span class=\"built_in\">add</span>(b, a);   <span class=\"comment\">//无向图，存两条边</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++) <span class=\"comment\">//遍历所有点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!color[i])  <span class=\"comment\">//若该点没有颜色</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">dfs</span>(i, <span class=\"number\">1</span>))\t<span class=\"comment\">//若对i点染色的过程出现了矛盾</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                flag = <span class=\"number\">0</span>;\t<span class=\"comment\">//说明该图不是二分图</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag) <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"匈牙利算法\"><a href=\"#匈牙利算法\" class=\"headerlink\" title=\"匈牙利算法\"></a>匈牙利算法</h2><p>​    匈牙利算法的作用是返回一个二分图的最大匹配。举个例子，令一个二分图分成a和b两个部分。从a部分开始遍历（从b部分开始也可以），如a[ i ]找和其相连的b部分的对应点b[ j ]形成配对。如果出现冲突，也就是b[ j ]已近和其他的点a[ x ]配对了，那就反过来看看a[ x ]能不能和别的配对，找个下家，如果可以的话b[ j ]就可以空出来和a[ i ]配对了。</p>\n<p>​    时间复杂度为O(mn)，实际运行时间一般远小于O(mn)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 &#123;E&#125; 中的任意两条边都不依附于同一个顶点（没有任何一个点在多条边上，也就是说一个点只和一条边配对），则称 M 是一个匹配。</span><br><span class=\"line\">二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</span><br></pre></td></tr></table></figure>\n\n<p>例题：二分图的最大匹配    来源Acwing模板题：<a href=\"https://www.acwing.com/problem/content/863/\">https://www.acwing.com/problem/content/863/</a></p>\n<p><img src=\"/2021/07/25/Graph/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%951.jpg\"></p>\n<p><img src=\"/2021/07/25/Graph/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%952.jpg\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">510</span>, M = <span class=\"number\">100010</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> h[N], e[M], ne[M];</span><br><span class=\"line\"><span class=\"keyword\">int</span> match[N];   <span class=\"comment\">//match[i]是和b[i]配对的a部分中的某个点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> book[N];    <span class=\"comment\">//book[]的作用是在想办法腾出位置（回溯）的时候，防止回溯过程中又读取到这个点。比如说现在a[i]想和b[i]配对，但是b[i]在之前已经和a[j]配对了，于是看看能不能让a[j]和另一个配对把b[i]的位置腾出来，这里就需要find(a[j])。为了防止find(a[j])的时候a[j]又读取到b[i]，就要来一个book，先帮a[i]“占位置”</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n1, n2, m, idx;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span>     <span class=\"comment\">//在b部分中找和x配对的点，找得到返回true</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = h[x]; i != <span class=\"number\">-1</span>; i = ne[i])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!book[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            book[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(match[j] == <span class=\"number\">0</span> || <span class=\"built_in\">find</span>(match[j]))  <span class=\"comment\">//若当前j点没有和a部分的点匹配或者能把j的位置腾出来</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                match[j] = x;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(a, b);  <span class=\"comment\">//只用连一条边就好了，因为整个算法过程都只遍历从a到b的边，不会用到b到a</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n1; i ++)  <span class=\"comment\">//任选两个部分其中一个开始遍历</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(book, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> book);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(i))</span><br><span class=\"line\">            res ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["Algorithm"],"tags":["Graph"]},{"title":"基础算法：数论","url":"/2021/09/17/Math/","content":"<p>一些数论的基础算法</p>\n<span id=\"more\"></span>\n\n<h3 id=\"一、质数\"><a href=\"#一、质数\" class=\"headerlink\" title=\"一、质数\"></a>一、质数</h3><p>​        质数的分解有三种方法</p>\n<h4 id=\"1-试除法-O-sqrt-n\"><a href=\"#1-试除法-O-sqrt-n\" class=\"headerlink\" title=\"1.试除法 O(sqrt(n))\"></a>1.试除法 O(sqrt(n))</h4><p>​        没啥好说的，就暴力。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= x / i; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-朴素筛法-O-n-log-n\"><a href=\"#2-朴素筛法-O-n-log-n\" class=\"headerlink\" title=\"2.朴素筛法 O(n * log n)\"></a>2.朴素筛法 O(n * log n)</h4><p>​        算法思想就是从i = 2开始，每次都把 i 的倍数给标记（筛）掉，这些数都是合数。只有当 i 为质数时才进行筛的操作，i 是合数直接continue</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> primes[N], cnt;  <span class=\"comment\">//primes[]拿来存质数， cnt是质数的个数</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> book[N]; <span class=\"comment\">//book用来标记一个数是否是质数,若book[i] = true，说明i不是质数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i ++) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(book[i]) <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">        primes[cnt ++] = i;\t<span class=\"comment\">//把质数保存下来</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &lt;= n; j += i) <span class=\"comment\">//i从2开始循环，第一轮会把所有2的倍数都筛掉；第二轮i=3时会把所有3的倍数都筛掉并标记，这样一直循环到n，没被标记过的数就一定是质数</span></span><br><span class=\"line\">            book[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-线性筛法-O-n-log-log-n\"><a href=\"#3-线性筛法-O-n-log-log-n\" class=\"headerlink\" title=\"3.线性筛法 O(n * log log n)\"></a>3.线性筛法 O(n * log log n)</h4><p>​        线性筛法能保证一个合数只会被筛一次，这样时间复杂度就降下来了</p>\n<p>​        首先是唯一分解定理：任何一个合数N，都可以被分解成有限个质数的乘积。设一个合数 x ，x必定存在一个最小质因数t，且一定有 x/t &lt; n，而 i 从2遍历到n，因此必定会出现 t * i = x的情况出现，故任何一个小于等于n的合数都会被标记。</p>\n<p>​        再证明primes[j] 一定是 primes[j] * i 的最小质因子：</p>\n<p>​        1.若 i % primes[j] == 0， 那么说明primes[j] 一定是 i 的最小质因子，也一定是primes[j] * i 的最小质因子</p>\n<p>​        2.若 i % primes[j] != 0，由于 primes[j] 是从小到大遍历的质数，那么 i 的最小质因子一定大于  primes[j] 。所以 primes[j] * i 的最小质因子一定是 primes[j]</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> primes[N], cnt; </span><br><span class=\"line\"><span class=\"keyword\">bool</span> book[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i ++)  </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!book[i]) primes[cnt ++] = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; primes[j] &lt;= n / i; j ++)<span class=\"comment\">//从小到大遍历所有已经存好的质数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            book[primes[j] * i] = <span class=\"literal\">true</span>; <span class=\"comment\">//要求primes[j] * i &lt; n</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % primes[j] == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>; <span class=\"comment\">//如果不及时结束的话，会把本该后面筛掉的数提前筛掉，就会导致一个数被筛多次而超时</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、约数\"><a href=\"#二、约数\" class=\"headerlink\" title=\"二、约数\"></a>二、约数</h3><p>​        求约数的话没有什么特别好的算法，就只有暴力试除法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n / i; i ++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x / i != i)  <span class=\"comment\">//避免出现res里面放两个平方根的情况</span></span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(x / i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(res.<span class=\"built_in\">begin</span>(), res.<span class=\"built_in\">end</span>());  <span class=\"comment\">//排序一下</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        此外有两个公式，可以很快的求约数的个数和约数之和：</p>\n<p><img src=\"/2021/09/17/Math/yueshu.jpg\"></p>\n<p>​        对于约数之和公式，有一个很好用的小模版：</p>\n","categories":["Algorithm"],"tags":["Number theory"]},{"title":"Ros","url":"/2021/07/20/Ros1/","content":"<h2 id=\"Ros学习笔记（一）\"><a href=\"#Ros学习笔记（一）\" class=\"headerlink\" title=\"Ros学习笔记（一）\"></a>Ros学习笔记（一）</h2><p>一些Linux基础命令</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Linux基础命令\"><a href=\"#Linux基础命令\" class=\"headerlink\" title=\"Linux基础命令\"></a>Linux基础命令</h3><h5 id=\"快捷键：Ctrl-Alt-t-打开终端\"><a href=\"#快捷键：Ctrl-Alt-t-打开终端\" class=\"headerlink\" title=\"快捷键：Ctrl+Alt+t 打开终端\"></a>快捷键：Ctrl+Alt+t 打开终端</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pwd  \t\t//显示当前终端工作目录的绝对路径</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd /home/   //进入home</span><br><span class=\"line\">$ cd ..      //返回上一级目录</span><br></pre></td></tr></table></figure>\n\n<p>​    <img src=\"/2021/07/20/Ros1/cd.jpg\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir (文件夹名)    //make direction:创建一个新的文件夹</span><br><span class=\"line\">$ ls               //list:查看当前路径下有哪些文件</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ touch test\t\t//在当前路径新建一个名为test的文件</span><br><span class=\"line\">$ mv test /home/laoyin/\t\t//move:把test剪切到目标位置/home/laoyin/下</span><br><span class=\"line\">$ cp test /home/laoyin/(new_name)\t//copy:把test复制到目标位置下，同时给新的test改个名字，也可以什么都不加</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rm test\t//remove:删除当前路径下的test文件</span><br><span class=\"line\">$ rm -r test\t//删除当前路径下的test文件夹</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo \t\t//提升当前用户的权限</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-amp-Python\"><a href=\"#C-amp-Python\" class=\"headerlink\" title=\"C++ &amp; Python\"></a>C++ &amp; Python</h3><p>首先先安装c++和python的编译器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install g++\t\t//cpp</span><br><span class=\"line\">$ sudo apt-get install python\t//python</span><br></pre></td></tr></table></figure>\n\n<p>c++的代码执行之前要先在终端里面编译，然后才能用终端执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ xxx.cpp -o xxx</span><br></pre></td></tr></table></figure>\n\n<p>这时候就会生成一个名为“xxx”的可执行文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./xxx</span><br></pre></td></tr></table></figure>\n\n<p>然后就用“./”（运行某个程序或者脚本），就可以运行了</p>\n<p>python不用编译，直接执行就行了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python xxx.py</span><br></pre></td></tr></table></figure>\n\n","categories":["Ros"],"tags":["Ros"]},{"title":"Ros2","url":"/2021/09/22/Ros2/","content":"<p><font size=\"6\"><strong>Ros学习笔记（二）</strong></font></p>\n<p>​        一些Ros 的命令行</p>\n<p>​        // Ctrl + Alt + T 快速打开终端</p>\n<p>​        输命令的时候按 Tab 可以自动补全，一些比较复杂的命令，要输参数那种的可以连着按两下 Tab 来补全输参数</p>\n<span id=\"more\"></span>\n\n<h3 id=\"创建工作空间和功能包\"><a href=\"#创建工作空间和功能包\" class=\"headerlink\" title=\"创建工作空间和功能包\"></a>创建工作空间和功能包</h3><p>​        创建工作空间，catkin_ws是文件夹名字，可以自定义，后面必须要加 /src !!</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir -p ~/catkin_ws/src</span><br><span class=\"line\">$ cd ~/catkin_ws/src</span><br><span class=\"line\">$ catkin_init_workspace</span><br></pre></td></tr></table></figure>\n\n<p>​        编译工作空间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd ~/catkin_ws/</span><br><span class=\"line\">$ catkin_make</span><br></pre></td></tr></table></figure>\n\n<p>​        设置环境变量，这步很重要，不然等会执行的时候master会找不到publisher文件在哪</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ source devel/setup.bash</span><br></pre></td></tr></table></figure>\n\n<p>​        检查环境变量是否设置ok，输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ echo $ROS_PACKAGE_PATH</span><br></pre></td></tr></table></figure>\n\n<p>​        如果显示如下，就说明设置成功了<img src=\"/2021/09/22/Ros2/ROS_workspace_init.jpg\"></p>\n<hr>\n<p>​        创建功能包，语法格式：</p>\n<p>​        $catkin_create_pkg <package_name> [depend1] [depend2] [depend3]</package_name></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd ~/catkin_ws/src</span><br><span class=\"line\">$ catkin_create_pkg test_pkg std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>\n\n<p>​        编译功能包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd ~/catkin_ws</span><br><span class=\"line\">$ catkin_make</span><br></pre></td></tr></table></figure>\n\n<p>​        之后就启动ros，然后用rosrun运行功能包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosrun &lt;功能包文件夹名字&gt; &lt;cpp/py 文件名&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"自定义话题\"><a href=\"#自定义话题\" class=\"headerlink\" title=\"自定义话题\"></a>自定义话题</h3><p>在功能包里，新建一个msg文件夹来存放msg文件        </p>\n<p><img src=\"/2021/09/22/Ros2/ros_yolo.jpg\"></p>\n<p>新建一个.msg文件，类似这种</p>\n<p><img src=\"/2021/09/22/Ros2/msg.jpg\"></p>\n<p>之后在功能包里的package.xml里加</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build_depend</span>&gt;</span>message_generation<span class=\"tag\">&lt;/<span class=\"name\">build_depend</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">exec_depend</span>&gt;</span>message_runtime<span class=\"tag\">&lt;/<span class=\"name\">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/09/22/Ros2/package.jpg\"></p>\n<p>在功能包的Cmakelist.xml里3个部分分别添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">find_package(</span><br><span class=\"line\">...message_generation</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/09/22/Ros2/cmakelist1.jpg\"></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">add_message_files(</span><br><span class=\"line\">   FILES</span><br><span class=\"line\">   Message1.msg</span><br><span class=\"line\">   Message2.msg</span><br><span class=\"line\"> )</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/09/22/Ros2/cmakelist2.png\"></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">catkin_package(</span><br><span class=\"line\">...message_runtime...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/09/22/Ros2/cmakelist3.png\"></p>\n<p>然后catkin_make编译，编译成功后会在 工作空间的根目录\\devel\\include\\功能包名字 里面发现.h文件</p>\n<p><img src=\"/2021/09/22/Ros2/.h.jpg\"></p>\n<hr>\n<h3 id=\"话题记录和话题复现\"><a href=\"#话题记录和话题复现\" class=\"headerlink\" title=\"话题记录和话题复现\"></a>话题记录和话题复现</h3><p>​        首先启动ros</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ roscore</span><br></pre></td></tr></table></figure>\n\n<p>​        话题记录，输入这个命令后，会在默认位置 home生成一个cmd_record.bag文件，这个文件记录了开启后的话题操作，可以用来复现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosbag record -a -O(大写的o) cmd_record</span><br></pre></td></tr></table></figure>\n\n<p>​        话题复现，就是把刚刚保存的数据复现出来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosbag play cmd_record.bag</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"参数配置命令行\"><a href=\"#参数配置命令行\" class=\"headerlink\" title=\"参数配置命令行\"></a>参数配置命令行</h3><p>​        ROS Master里面有一个参数服务器Parameter Server，相当于一个全局字典，里面的值（如：/robot_name : “robot1”）任何一个Node都可以访问使用</p>\n<p>​        列出当前参数列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosparam list</span><br></pre></td></tr></table></figure>\n\n<p>​        显示某个参数的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosparam get xxx</span><br></pre></td></tr></table></figure>\n\n<p>​        改变某个参数的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosparam set xxx new_value</span><br></pre></td></tr></table></figure>\n\n<p>​        删除某个参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosparam delete xxx</span><br></pre></td></tr></table></figure>\n\n<p>​        保存当前参数列表到某个文件，此文件的后缀是yaml，会自动生成在当前终端的默认路径下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosparam dump file_name.yaml</span><br></pre></td></tr></table></figure>\n\n<p>​        从某个文件读取参数列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rosparam load file_name.yaml</span><br></pre></td></tr></table></figure>\n\n","categories":["Ros"],"tags":["Ros"]},{"title":"STL","url":"/2021/09/08/STL/","content":"<p>关于一些cpp STL库函数的用法</p>\n<p>万能头文件 ： #include&lt;bits/stdc++.h&gt;</p>\n<span id=\"more\"></span>\n\n<h3 id=\"unordered-map\"><a href=\"#unordered-map\" class=\"headerlink\" title=\"unordered_map\"></a>unordered_map</h3><hr>\n<p>哈希表，也可以当字典来用</p>\n<p>比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">unordered_map&lt;string, <span class=\"keyword\">int</span>&gt; ss;</span><br><span class=\"line\">ss[<span class=\"string\">&quot;laoyin&quot;</span>] = <span class=\"number\">666</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这时候 cout &lt;&lt; ss[“laoyin”] 就会输出666</p>\n<p>也可以：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">ss.<span class=\"built_in\">insert</span>(&#123;<span class=\"string\">&quot;laoyin&quot;</span>, <span class=\"number\">666</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果想要哈希表里面的值（即ss[“laoyin”]）迭代增加或者减小的话，可以直接：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ss[<span class=\"string\">&quot;laoyin&quot;</span>] ++;</span><br></pre></td></tr></table></figure>\n\n<p>遍历ss里面的值的话，可以</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; [k, v] : ss) res = <span class=\"built_in\">max</span>(res, v);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unordered-set\"><a href=\"#unordered-set\" class=\"headerlink\" title=\"unordered_set\"></a>unordered_set</h3><hr>\n<p>和set一样，一个不允许有重复元素的容器</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">unordered_set&lt;<span class=\"keyword\">int</span>&gt; ss;</span><br><span class=\"line\">ss.<span class=\"built_in\">insert</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">cout &lt;&lt; ss.<span class=\"built_in\">count</span>(<span class=\"number\">1</span>) &lt;&lt; endl;  <span class=\"comment\">//输出1</span></span><br></pre></td></tr></table></figure>\n\n<p>可以用 ss.count(a) 来判断set中是否存在a，由于set中不允许出现重复元素，因此返回值只有0 和 1。</p>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><hr>\n<p>类似一个数组</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; a;</span><br><span class=\"line\">a.<span class=\"built_in\">push_back</span>(<span class=\"number\">666</span>);</span><br></pre></td></tr></table></figure>\n\n<p>想给vector排序的话可以：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(), a.<span class=\"built_in\">end</span>());</span><br></pre></td></tr></table></figure>\n\n<p>遍历：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> t : a) cout &lt;&lt; t &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>判断两个vector是否相等可以直接：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; a;</span><br><span class=\"line\">vector&lt;<span class=\"keyword\">int</span>&gt; b;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a == b) </span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n\n<p>此外，vector中clear的作用只是将size置0，原来有的元素还是会在里面：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">30</span>)</span></span>;  <span class=\"comment\">//预分配30个空间给a</span></span><br><span class=\"line\">a[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">a.<span class=\"built_in\">clear</span>();    <span class=\"comment\">//clear完后a[1]还是等于1。换成erase也是一样的，a[1]还是1</span></span><br></pre></td></tr></table></figure>\n\n<p>如果想将vector置0，可以用assign:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">a.<span class=\"built_in\">assign</span>(<span class=\"number\">26</span>, <span class=\"number\">0</span>); \t<span class=\"comment\">//将前26个元素全部置0</span></span><br></pre></td></tr></table></figure>\n\n","tags":["STL"]},{"title":"汇编实验：查找电话号码","url":"/2021/11/26/assembly-1/","content":"<p>​    使用汇编语言编写一个能存储电话号码，并拥有查找功能的程序</p>\n<span id=\"more\"></span>\n\n<h3 id=\"实验任务\"><a href=\"#实验任务\" class=\"headerlink\" title=\"实验任务\"></a>实验任务</h3><p>1）要求建立一个可以存入50项的电话号码表，每项包括人名（20字符）和电话号码（8字符）两部分;<br>2）程序可以接受用户输入的人名及相应的电话号码，并把它们加入到电话号码表中;<br>3）凡有新的输入后，程序可以按人名对电话号码进行排序;<br>4）程序可接收需要查找的电话号码的人名，并从电话号码表中查出电话号码，再在屏幕上以如下格式显示<br>name         tel<br>xxxxx         xxxxxxxxxx</p>\n<h3 id=\"实验思路\"><a href=\"#实验思路\" class=\"headerlink\" title=\"实验思路\"></a>实验思路</h3><p>​        创建一个db类型的tel_tab来存储电话号码和人名，另创两个label byte inname 和 ipphone来临时存放人名和电话号码，先存进这里面，存好之后再用rep movsb往tel_tab里面搬。</p>\n<p>​        查找的时候输入姓名在inname里面，用si指向它；用di指向tel_tab表头，对于tel_tab里面的元素每次都和si里的人名用repe cmpsb比较，若匹配成功说明找到了，输出；匹配失败则add di , 28 指向下一个元素，si重新归位，继续下一次比较，直到找完tel_tab里面所有的东西都没有找到为止返回。</p>\n<h3 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">data    segment</span><br><span class=\"line\">    count   dw  0</span><br><span class=\"line\">    tel_tab db  50 dup (20 dup (?) , 8 dup (?))</span><br><span class=\"line\">    msg1    db  &#x27;Input name:&#x27;, &#x27;$&#x27;</span><br><span class=\"line\">    msg2    db  &#x27;Input a telephonee number:&#x27;, &#x27;$&#x27;</span><br><span class=\"line\">    msg3    db  &#x27;Do you want a telephone number?(Y/N)&#x27;,&#x27;$&#x27;</span><br><span class=\"line\">    msg4    db  &#x27;name?&#x27;,&#x27;$&#x27;</span><br><span class=\"line\">    msg5    db  &#x27;name                tel.&#x27;,&#x27;$&#x27;</span><br><span class=\"line\">    inname  label   byte</span><br><span class=\"line\">    inmax   db  21      ;最大长度</span><br><span class=\"line\">    inact   db  ?       ;数组长度</span><br><span class=\"line\">    inn     db  21 dup (?)      ;具体内容</span><br><span class=\"line\">    ipphone label   byte</span><br><span class=\"line\">    ipmax   db  9</span><br><span class=\"line\">    ipact   db  ?</span><br><span class=\"line\">    ipp     db  9 dup (?)</span><br><span class=\"line\">    cbuf    db  28 dup (?)</span><br><span class=\"line\">data    ends   </span><br><span class=\"line\">code    segment</span><br><span class=\"line\">        assume  cs:code, ds:data, es:data</span><br><span class=\"line\">main    proc    far</span><br><span class=\"line\">        push    ds</span><br><span class=\"line\">        sub     ax , ax</span><br><span class=\"line\">        push    ax</span><br><span class=\"line\">        mov     ax , data       </span><br><span class=\"line\">        mov     ds , ax     ;初始化，ds = data</span><br><span class=\"line\">        mov     es , ax     ;es = data</span><br><span class=\"line\">        lea     bx , tel_tab</span><br><span class=\"line\">        mov     di , bx</span><br><span class=\"line\">new:    lea     dx , msg1  ;输出msg1</span><br><span class=\"line\">        mov     ah , 09h</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        call    input_name</span><br><span class=\"line\">        call    crlf</span><br><span class=\"line\">        mov     al , inact</span><br><span class=\"line\">        cmp     al , 0   ;什么都不输直接按回车</span><br><span class=\"line\">        jz      sort     ;相等跳转</span><br><span class=\"line\">        call    stor_name   ;从data:inn搬到data:tel_tab</span><br><span class=\"line\">        inc     count</span><br><span class=\"line\">        lea     dx , msg2   ;输出msg2</span><br><span class=\"line\">        mov     ah , 09h</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        call    inphone</span><br><span class=\"line\">        call    crlf</span><br><span class=\"line\">        cmp     count , 50</span><br><span class=\"line\">        jl      new     ;电话号码数量小于50，返回</span><br><span class=\"line\">sort:</span><br><span class=\"line\">        call    name_sort</span><br><span class=\"line\">ask_again:</span><br><span class=\"line\">        call    crlf</span><br><span class=\"line\">        lea     dx , msg3   ;ds:dx = data:msg3</span><br><span class=\"line\">        mov     ah , 09h    ;输出字符串</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        mov     ah , 01h    ;输入单个字符，存在al里</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        cmp     al , 4eH    ;若输入为N</span><br><span class=\"line\">        je      return</span><br><span class=\"line\">        call    crlf</span><br><span class=\"line\">        cmp     al , 59H    ;若输入为Y</span><br><span class=\"line\">        jne     ask_again</span><br><span class=\"line\">        call    crlf</span><br><span class=\"line\">        lea     dx , msg4   ;输出msg4</span><br><span class=\"line\">        mov     ah , 09h</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        call    input_name  ;重新输入名字</span><br><span class=\"line\">        call    name_search ;查找名字 </span><br><span class=\"line\">        call    printline</span><br><span class=\"line\">        jmp     ask_again </span><br><span class=\"line\">return:</span><br><span class=\"line\">        ret</span><br><span class=\"line\">main    endp</span><br><span class=\"line\">input_name  proc</span><br><span class=\"line\">        push    di          ;tel_tab</span><br><span class=\"line\">        lea     dx , inname</span><br><span class=\"line\">        mov     ah , 0ah    ;输入到data:inname</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        lea     di , inn    ;首地址</span><br><span class=\"line\">        mov     al , inact  ;长度</span><br><span class=\"line\">        cbw</span><br><span class=\"line\">        add     di , ax     ;指针指向尾部</span><br><span class=\"line\">        mov     cx , 21</span><br><span class=\"line\">        sub     cx , ax     ;得到剩余长度</span><br><span class=\"line\">        mov     al , 20h    ;ascall码为空格</span><br><span class=\"line\">        cld                 ;使DF复位，DF = 0,内存地址向高地址增加</span><br><span class=\"line\">        rep     stosb       ;将AL的值即空格存到ES:DI所指向的位置,清空数组</span><br><span class=\"line\">        pop     di</span><br><span class=\"line\">        ret    </span><br><span class=\"line\">input_name  endp</span><br><span class=\"line\">stor_name   proc</span><br><span class=\"line\">        lea     si , inn</span><br><span class=\"line\">        mov     cx , 20 ;字符串长度</span><br><span class=\"line\">        cld</span><br><span class=\"line\">        rep     movsb   ;把字节从ds:si搬到es:di，从data:inn搬到data:tel_tab</span><br><span class=\"line\">        ret</span><br><span class=\"line\">stor_name   endp</span><br><span class=\"line\">crlf    proc</span><br><span class=\"line\">        push    dx</span><br><span class=\"line\">        push    ax</span><br><span class=\"line\">        mov     dl , 0dh    ;回车</span><br><span class=\"line\">        mov     ah , 02h</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        mov     dl , 0ah</span><br><span class=\"line\">        mov     ah , 02h    ;换行</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        pop     ax</span><br><span class=\"line\">        pop     dx</span><br><span class=\"line\">        ret</span><br><span class=\"line\">crlf    endp</span><br><span class=\"line\">inphone proc</span><br><span class=\"line\">        push    di          ;此时di为tel_tab的首地址</span><br><span class=\"line\">        lea     dx , ipphone    ;输入到ipphone</span><br><span class=\"line\">        mov     ah , 0ah</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        lea     di , ipp    ;数组首地址</span><br><span class=\"line\">        mov     al , ipact  ;数组长度</span><br><span class=\"line\">        cbw</span><br><span class=\"line\">        add     di , ax     ;此时di所存为数组尾部地址</span><br><span class=\"line\">        mov     cx , 9</span><br><span class=\"line\">        sub     cx , ax     ;求数组剩余空间</span><br><span class=\"line\">        mov     al , 20h    ;空格</span><br><span class=\"line\">        cld</span><br><span class=\"line\">        rep     stosb       ;清空数组</span><br><span class=\"line\">        pop     di</span><br><span class=\"line\">        lea     si , ipp</span><br><span class=\"line\">        mov     cx , 8      ;字符串长度</span><br><span class=\"line\">        cld </span><br><span class=\"line\">        rep     movsb       ;把ds:si的东西搬到es:di</span><br><span class=\"line\">        ret</span><br><span class=\"line\">inphone endp</span><br><span class=\"line\">name_sort   proc    ;冒泡排序</span><br><span class=\"line\">    mov     bx , count</span><br><span class=\"line\">    dec     bx</span><br><span class=\"line\">s3:</span><br><span class=\"line\">    lea     si , tel_tab</span><br><span class=\"line\">    mov     di , si</span><br><span class=\"line\">    add     di , 28     ;电话表第二行首地址</span><br><span class=\"line\">    mov     cx , bx     ;count</span><br><span class=\"line\">s2:</span><br><span class=\"line\">    push    si          ;tel_tab地址</span><br><span class=\"line\">    push    di          ;电话表第二行首地址</span><br><span class=\"line\">    push    cx          ;count</span><br><span class=\"line\">    mov     cx , 28</span><br><span class=\"line\">    cld</span><br><span class=\"line\">    repe    cmpsb       ;字符串比较</span><br><span class=\"line\">    pop     cx</span><br><span class=\"line\">    pop     di</span><br><span class=\"line\">    pop     si</span><br><span class=\"line\">    jl      s1          ;若[si] &lt; [di]，跳转</span><br><span class=\"line\">    call    exchange    ;反之若[si] &gt; [di]交换位置</span><br><span class=\"line\">s1:</span><br><span class=\"line\">    add     si , 28     ;指针后移</span><br><span class=\"line\">    add     di , 28     ;指针后移</span><br><span class=\"line\">    loop    s2</span><br><span class=\"line\">    dec     bx</span><br><span class=\"line\">    jnz     s3          ;count不为零则跳转s3    </span><br><span class=\"line\">    ret</span><br><span class=\"line\">name_sort endp</span><br><span class=\"line\">;----------------------------</span><br><span class=\"line\">name_search     proc  </span><br><span class=\"line\">        lea     di , tel_tab ;di指向表头</span><br><span class=\"line\">        mov     dx , count   ;计数器</span><br><span class=\"line\">ss1:    lea     si , inn     ;si指向要找的名字，每次循环之前把si指针归位</span><br><span class=\"line\">        dec     dx</span><br><span class=\"line\">        mov     al , inact   ;只用循环数组长度次数就可以了，如果循环28次的话，假设当前是匹配的</span><br><span class=\"line\">                             ;那么再循环了inact次之后剩下后面的会因为不匹配而报错 </span><br><span class=\"line\">        cbw                  ;字节转换成字</span><br><span class=\"line\">        mov     cx , ax </span><br><span class=\"line\">        cld</span><br><span class=\"line\">        push    di</span><br><span class=\"line\">        repe    cmpsb        ;字符串比较,cx等于0说明匹配</span><br><span class=\"line\">        pop     di</span><br><span class=\"line\">        jz      ss2          ;等于0跳s2</span><br><span class=\"line\">        add     di , 28      ;指针后移</span><br><span class=\"line\">        cmp     dx , 0</span><br><span class=\"line\">        jne     ss1          ;如果没找到的话就回去重新找</span><br><span class=\"line\">        ret </span><br><span class=\"line\">ss2:</span><br><span class=\"line\">        ret</span><br><span class=\"line\">name_search     endp</span><br><span class=\"line\">;----------------------------</span><br><span class=\"line\">printline       proc</span><br><span class=\"line\">        lea     dx , msg5  ;输出msg5</span><br><span class=\"line\">        mov     ah , 09h</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        call    crlf</span><br><span class=\"line\">        push    cx</span><br><span class=\"line\">        mov     cx , 28</span><br><span class=\"line\">printchar:                ;把要输出的字符串拆成28个字符单个输出</span><br><span class=\"line\">        mov     dl , [di]</span><br><span class=\"line\">        mov     ah , 02h</span><br><span class=\"line\">        int     21h</span><br><span class=\"line\">        add     di , 1</span><br><span class=\"line\">        loop    printchar</span><br><span class=\"line\">        pop     cx</span><br><span class=\"line\">        ret</span><br><span class=\"line\">printline       endp</span><br><span class=\"line\">exchange    proc\t</span><br><span class=\"line\">    push    cx      ;count</span><br><span class=\"line\">    push    si      ;tel_tab地址，要被交换的地址</span><br><span class=\"line\">    push    di      ;下一个号码的地址，另一个要被交换的地址</span><br><span class=\"line\">    push    ax      ;data</span><br><span class=\"line\">    push    bx      ;tel_tab</span><br><span class=\"line\">    mov     ax , si</span><br><span class=\"line\">    mov     bx , di</span><br><span class=\"line\">    lea     di , cbuf</span><br><span class=\"line\">    mov     cx , 28</span><br><span class=\"line\">    cld</span><br><span class=\"line\">    rep     movsb   ;把si的东西搬到cbuf</span><br><span class=\"line\">    mov     di , ax     ;di = si</span><br><span class=\"line\">    mov     si , bx     ;si = di</span><br><span class=\"line\">    mov     cx , 28</span><br><span class=\"line\">    cld</span><br><span class=\"line\">    rep     movsb   ;把di的东西搬到si</span><br><span class=\"line\">    lea     si , cbuf</span><br><span class=\"line\">    mov     bx , di</span><br><span class=\"line\">    mov     cx , 28</span><br><span class=\"line\">    cld </span><br><span class=\"line\">    rep     movsb</span><br><span class=\"line\">    pop     bx</span><br><span class=\"line\">    pop     ax</span><br><span class=\"line\">    pop     di</span><br><span class=\"line\">    pop     si</span><br><span class=\"line\">    pop     cx</span><br><span class=\"line\">    ret</span><br><span class=\"line\">exchange endp</span><br><span class=\"line\">code    ends   </span><br><span class=\"line\">        end     main</span><br></pre></td></tr></table></figure>\n\n\n\n","tags":["Assembly Language"]},{"title":"序章","url":"/2021/07/17/starts/","content":"<center>\n<font size=\"6.5\">\n    「Hello World」\n\n<center><font size=\"3\">欢迎来到我的小屋。\n\n<center>平时会写一写一些学到的东西，如果喜欢的话谢谢欣赏\n\n<hr>\n<center>除了打代码，平时还喜欢看点历史，偶尔也会写个一两篇，欢迎关注我的历史小屋\n\n<p><img src=\"/2021/07/17/starts/small.jpg\"></p>\n<center>老鹰的历史小屋\n<span id=\"more\"></span></center></center></center></font></center></font></center>"},{"title":"零碎的算法知识点","url":"/2021/12/06/tip/","content":"<p> 记录一下刷题过程中遇到的一些小知识点</p>\n<span id=\"more\"></span>\n\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p>定义一个链表：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个新节点（自动分配空间）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode* p = <span class=\"keyword\">new</span> ListNode</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string.<span class=\"built_in\">length</span>();    <span class=\"comment\">//读取字符串长度</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h3><p>整数二分有两种区间划分法：</p>\n<p>1.mid在左，即分成【l，mid】和【mid + 1，r】，计算mid时向下取整：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(nums[mid] &gt;= target) r = mid;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.mid在右，即分成【l，mid - 1】 和【mid，r】，计算mid时向上取整（需加1）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = l + r + <span class=\"number\">1</span> &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(nums[mid] &lt;= target) l = mid;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.如果想精确的找到某个值，可以：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l &lt;= r)\t<span class=\"comment\">//这里一定要是&lt;=，因为很可能在l = r的时候才刚好定位到符合条件的mid</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] &lt; target) l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","tags":["tips"]}]